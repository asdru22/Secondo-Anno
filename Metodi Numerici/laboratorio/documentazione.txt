%aggiunge il path della libreria anmglib ai path di Matlab

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function axis_plot(lax)
%Disegna il sistema di assi cartesiani 2D o 3D
%lax --> lunghezza degli assi (se il parametro viene omesso si
%        assume la lunghezza 1)
%parametri obsoleti: ignorare
%sc --> fattore di scala per dimensione freccia del vettore
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Scelta euristica di sc per il disegno della freccia degli assi coordinati

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function basis_bernst1d_plot(g,a,b)
%Valuta e disegna la base di Bernstein univariata
%g    --> grado 
%a,b  --> intervallo di definizione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%l'intervallo [a,b] viene discretizzato in m punti
%cambio di variabile
%base di Bernstein in [0,1]
%disegno di tutte le funzioni base

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function basis_bernst2d_plot(gu,gv,a,b,c,d)
%Valuta e disegna la base di Bernstein bivariata
%gu,gv  --> grado
%a,b  --> intervallo di definizione in u
%c,d  --> intervallo di definizione in v
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%l'intervallo [a,b]x[c,d] viene discretizzato in mxm punti
%base di Bernstein
%disegno di tutte le funzioni base
%disegna funzione base (i,j)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function basis_nurbs1d_plot(g,t,w)
%Valuta e disegna la base rational B-spline univariata
%g    --> grado
%t    --> vettore dei knot
%w    --> lista dei pesi di ncp elementi
%         ricorda: ncp=numero nodi - g - 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   g=3;
%   t=[0 0 0 0 0.26 0.26 0.26 0.5 0.75 1 1 1 1];
%   w=[1 1 1 1 0.0125 1 1 1 1];
%   g=3;
%   t=[0 0 0 0 1 1 1 1];
%   w=[1 5 5 1];
%griglia di valutazione uniforme su [a,b]
%x=linspace(a,b,36);
%Colori
%Codice per grafico B-spline

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function basis_nurbs2d_plot(gu,u,gv,v,W)
%Valuta e disegna la base rational B-spline bivariata
%gu,gv  --> grado
%u      --> vettore dei knot in u
%v      --> vettore dei knot in v
%W      --> matrice dei pesi di dimensione ncpu x ncpv
%           ricorda: ncp=numero nodi - gu -1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%*********************************************
% basi B-spline Normalizzate bivariate come caso
% particolare di RB-spline
%*********************************************
% gu=2;
% gv=3;
% h=3;
% k=4;
% u=[zeros(1,gu) linspace(0,1,h) ones(1,gu)];
% wu=ones(1,2*(gu+1)+h);
% v=[zeros(1,gv) linspace(0,1,k) ones(1,gv)];
% wv=ones(1,2*(gv+1)+k);
% W=wu'*wv;
%*********************************************
% basi RB-spline Normalizzate bivariate
%*********************************************
% gu=2;
% gv=3;
% h=3;
% k=4;
% u=[zeros(1,gu) linspace(0,1,h) ones(1,gu)];
% wu=ones(1,2*(gu+1)+h);
% wu(4)=5;
% v=[zeros(1,gv) linspace(0,1,k) ones(1,gv)];
% wv=ones(1,2*(gv+1)+k);
% wv(6)=5;
% W=wu'*wv;
%*********************************************
% basi RB-spline Normalizzate bivariate con nodi doppi
%*********************************************
% gu=2;
% gv=3;
% h=2;
% k=3;
% nodi=[0 0.5 0.5 1];
% u=[zeros(1,gu) nodi ones(1,gu)];
% wu=ones(1,2*(gu+1)+h);
% wu(4)=5; wu(5)=5;
% v=[zeros(1,gv) linspace(0,1,k) ones(1,gv)];
% wv=ones(1,2*(gv+1)+k);
% wv(5)=5; wv(6)=5;
% W=wu'*wv;
%*********************************************
%griglia di valutazione uniforme su [a,b]
%disegna funzione base (i,j)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function basis_spline1d_plot(g,t,flag)
%Valuta e disegna la base B-spline univariata
%g    --> grado
%t    --> vettore dei knot
%flag --> 1 solo B-spline
%         2 B-spline e derivate prime
%         3 B-spline e derivate prime e seconde
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%t=[0 0 0 0 0.3 0.7 1 1 1 1];
%t=[0 1 2 3 4 5 6 7 8 9 10];
%griglia di valutazione uniforme su [a,b]
%Colori
%Codice per grafico B-spline
%  y=gc_bspl(g,t,x);
%figure(1);
%Codice per grafico B-spline e derivate prima
%  [y,y1]=gc_bpspl(g,t,x);
%figure(1);
%figure(2);
%Codice per grafico B-spline, derivate prima e seconda
%  [y,y1,y2]=gc_bpsspl(g,t,x);
%figure(1);
%figure(2);
%figure(3);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function basis_spline2d_plot(gu,u,gv,v)
%Valuta e disegna la base B-spline bivariata
%gu,gv  --> grado
%u  --> vettore dei knot in u
%v  --> vettore dei knot in v
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% basi di Bernstein bivariate
%*********************************************
% gu=2;
% gv=3;
% u=[zeros(1,gu+1) ones(1,gu+1)];
% v=[zeros(1,gv+1) ones(1,gv+1)];
%*********************************************
% basi B-spline Normalizzate bivariate
%*********************************************
%*********************************************
% basi B-spline Normalizzate bivariate con nodi doppi
%*********************************************
% gu=2;
% gv=3;
% h=2;
% k=3;
% nodi=[0 0.5 0.5 1];
% u=[zeros(1,gu) nodi ones(1,gu)];
% v=[zeros(1,gv) linspace(0,1,k) ones(1,gv)];
%*********************************************
%griglia di valutazione uniforme su [a,b]
%figura con B-spline bivariate
%Valutazione B-spline
%  zx=gc_bspl(gu,u,x);
%  zy=gc_bspl(gv,v,y);
%disegna funzione base (i,j)
%  figure;
%  view(45,30);
%  i=4; j=3;
%         Z=zy(:,j)*zx(:,i)';
%        %disegna funzione base (i,j)
%        mesh(X,Y,Z);
% 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function bs=bernst(g,x)
%Valuta le funzioni base di Bernstein di grado g nei punti x in [0,1]
%g  --> grado
%x  --> punti in [0,1] in cui valutare
%bs <-- matrice delle funzioni di Bernstein nei punti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% B_{j,i}(t) = t * B_{j-1,i-1}(t) + (1-t) * B_{j,i-1}(t) j=0,..,n
% B_{j-1,i}(t) = t * B_{j-1,i-1}(t) + (1-t) * B_{j,i-1}(t) j=n,..,0
%Formula ricorrente 
%B_{j,i}(t) = t * B_{j-1,i-1}(t) + (1-t) * B_{j,i-1}(t) j=0,..,n
%
%B_{j-1,i-1} B_{j,i-1} B_{j+1,i-1}    j=0,..,i-1
%          \  |      \ |
% -->   ...  B_{j,i}   B_{j+1,i}      j=0,..,i
%
%Implementazione in un array
%B(j-1) = t * B(j-1) + (1-t) * B(j) j=n,..,0
%
%B(j-1) B(j) B(j+1)   j=n,..,n-i
%     |  /   | /
%B(j-1) B(j)  ...     j=n,..,n-i+1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [bs,bsp]=bernst_valder(g,x)
%Valuta le funzioni base di Bernstein di grado g e le loro derivate
%prime nei punti x in [0,1]
%g  --> grado
%x  --> punti in [0,1] in cui valutare
%bs <-- matrice delle funzioni di Bernstein nei punti
%bsp<-- matrice delle funzioni di Bernstein derivate prima nei punti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% calcolo dei valori di derivata prima   
% fine calcolo derivata si continua con i valori   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function roots = bezier_clipping(fun,TOL)
%Determina gli zeri di una funzione polinomiale data nella base di 
%Bernstein in un intervallo (quello di definizione della base);
%utilizza il metodo denominato in letteratura 'Bézier Clipping'
%fun   --> struttura funzione polinomiale nella base di Bernstein 
%TOL   --> tolleranza
%roots <-- vettore delle radici trovate
%Nota. al momento questa function non viene richiamata da nessuna
%      funzione della libreria; la si trova commentata nelle
%      funzioni curv2_bezier_offset.m e curv2_ppbezier_offset.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%inizializzazioni
%    stampa(1,Bezier_idx,buf);
%tutti i coefficienti sono o > 0 oppure < 0
%        stampa(2,Bezier_idx,buf);
%s contiene gli indici dei coefficienti che
%stanno sopra o sulla retta che congiunge il primo
%e l'ultimo dei coefficienti, mentre g quelli che
%stanno sotto
%for   
%         disp('s-g')
%         disp(s)
%         disp(g)
%XA: l'estremo destro
%        plot([p.a,x],[p.cp(1),y],'g-');
%XB: l'estremo sinistro
%        plot([x,p.b],[y,p.cp(degree+1)],'r-');
%         plot([xa,xa],[-1,1],'m-');
%         plot([xb,xb],[-1,1],'c-')
%            stampa(3,Bezier_idx,buf);
%                stampa(4,Bezier_idx,buf);
%                stampa(4,Bezier_idx,buf);
%                stampa(5,Bezier_idx,buf);
%else
%while
%funzione di stampa per fare debug
% for i=1:Bezier_idx
%    fprintf('indice %d \n',i);
%    disp(buf(i));
%    disp(buf(i).cp);
% end
%predispone lo stack a ricevere un nuovo elemento
% Inizializzazione dell'indice dello stack
% Controllo per vedere se lo stack e' vuoto
% Viene presa la funzione piu' in alto sullo stack
% Si decrementa l'indice dello stack 
% Si inserisce un elemento nello stack
% buf(Bezier_idx)=q; %pare che così non vada bene
% procediamo a copiare campo per campo
% si copia e trasforma il vettore cp in un vettore riga
%clipping a sinistra
%clipping a destra
%suddivide in due

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [vecx,vecy]=c2_offset_rec_val(cp2name,tin,pin,tmed,fmed,tfin,pfin,d,vecx,vecy,tol)
%Valutazione adattiva via suddivisione di una curva 2D
%cp2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%tin,pin --> valore parametrico e punto curva relativo al primo estremo
%tmed,fmed --> valore parametrico e punto curva relativo al primo estremo
%tfin,pfin --> valore parametrico e punto curva relativo al secondo estremo
%d --> distanza positiva o negativa della curva offset dalla curva data
%vecx,vecy --> coordinate dei punti gia' valutati
%tol --> tolleranza di valutazione
%vecx,vecy <-- coordinate dei punti in uscita
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [vecx,vecy]=c2_rec_val(c2name,tin,pin,tmed,fmed,tfin,pfin,vecx,vecy,tol)
%Valutazione adattiva via suddivisione di una curva 2D
%c2name --> nome del file con l'espressione parametrica della curva
%tin,pin --> valore parametrico e punto curva relativo al primo estremo
%tmed,fmed --> valore parametrico e punto curva relativo al primo estremo
%tfin,pfin --> valore parametrico e punto curva relativo al secondo estremo
%vecx,vecy --> coordinate dei punti valutati fino ad ora
%tol --> tolleranza di valutazione
%vecx,vecy <-- coordinate dei punti in uscita
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=c3_circleXY(t)
%Definizione parametrica della circonferenza 3D di centro
%l'origine e raggio unitario sul piano XY
%t     --> parametro in [0,2*pi]
%x,y,z --> punto 3D della circonferenza
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=c3_circleXYZ(O,r,n,t)
%Definizione parametrica della circonferenza 3D di centro 
%l'origine e raggio r sul piano definito dal punto O
%e dalla normale n
%O     --> punto 3D
%r     --> raggio della circonferenza
%n     --> normale che definisce il piano
%t     --> parametro in [0,2*pi]
%x,y,z --> punto 3D della circonferenza
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=c3_line4(t)
%Definizione parametrica di una retta 3D
%t     --> parametro in R
%x,y,z --> punto 3D della retta
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=c3_line5(t)
%Definizione parametrica di una retta 3D
%t     --> parametro in R
%x,y,z --> punto 3D della retta
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y]=circle2_plot(O,r,np,varargin)
%Disegna sul piano cartesiano una circonferenza di centro O e raggio r
%O  --> centro 2D della circonferenza
%r  --> raggio
%np --> numero di punti del disegno
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare, in ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%x,y <-- coordinate punti disegnati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y] = circle2_trans_plot(O,r,np,M,varargin)
%Disegna sul piano cartesiano una circonferenza di centro O e raggio r dopo
%averla traformata con la matrice M 3x3
%O  --> centro 2D della circonferenza
%r  --> raggio
%np --> numero di punti del disegno
%       se negativo si valuta, ma non si disegna
%M  --> matrice 3x3 di trasformazione
%varargin --> argomenti opzionali di disegno da assegnare, in ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%x,y <-- coordinate punti disegnati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function nurbs=circle_nurbs(O,r,n)
%Determina sul piano definito dal punto 3D O e dal vettore 
%normale n una circonferenza nurbs di centro O e raggio r
%O  --> punto 3D
%r  --> raggio
%n  --> vettore normale 3D
%nurbs <-- struttura formata da 4 campi:
%          nurbs.deg <-- grado della curva
%          nurbs.cp  <-- lista dei punti di controllo
%          nurbs.knot  <-- vettore dei nodi
%          nurbs.w <-- lista dei pesi (weight)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function circle_plot(O,r,n,np,varargin)
%Disegna sul piano definito dal punto 3D O e dal vettore 
%normale n una circonferenza di centro O e raggio r
%O  --> punto 3D
%r  --> raggio
%n  --> vettore normale 3D
%np --> numero di punti del plot
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare, in ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%x,y,z <-- coordinate punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z] = circle_trans_plot(O,r,n,np,M,varargin)
%Disegna sul piano definito dal punto 3D O e dal vettore
%normale n una circonferenza di centro O e raggio r dopo
%averla traformata con la matrice M
%O  --> punto 3D
%r  --> raggio
%n  --> vettore normale 3D
%np --> numero di punti del plot
%       se negativo si valuta, ma non si disegna
%M  --> matrice 4x4 di trasformazione
%varargin --> argomenti opzionali di disegno da assegnare, in ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%x,y,z <-- coordinate punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [vecx,vecy]=curv2_adapt_plot(c2name,a,b,tol,varargin)
%Disegna una curva 2D
%c2name --> nome del file con l'espressione parametrica della curva
%a,b --> intervallo di definizione
%tol --> tolleranza di valutazione
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%vecx,vecy <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy] = curv2_bezier_comb_plot(bezier,np,varargin)
%Disegna il comb di una curva 2D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%np  --> numero di punti di valutazione
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%npx,npy <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bernst = bernst_der2(bezier.deg,t);
%Px(:,1)=bas_bernst*bezier.cp(:,1);
%Px(:,2)=bas_bernst*bezier.cp(:,2);
%Algoritmo2
% for i=1:abs(np)
%     td(i)=norm([xp(i),yp(i)],2);
%     tx(i)=xp(i)/td(i);
%     ty(i)=yp(i)/td(i);
% end
% for i=1:abs(np)
%     plot([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],'g-')
% end
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function bezier = curv2_bezier_interp(Q,a,b,param)
%Calcola la curva 2D di Bezier di interpolazione dei punti Q
%Q --> lista dei punti 2D di interpolazione (g+1)x2
%a,b --> intervallo di interpolazione
%param --> scelta della parametrizzazione
%           0=uniforma, 1=centripeta, 2=corda
%bezier <-- struttura della curva 2D di Bezier :
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo
%          bezier.ab  --> intervallo di definizione [a b]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% bma=b-a;
%parametrizzazione
%alpha=0.0;  %uniforme
%alpha=0.5;  %centripeta
%alpha=1.0;  %corda
%Calcola parametrizzazione
%fine parametrizzazione
%forma di Bernstein (Matrice delle funzioni base nei punti)
%tt=(t-a)./bma;
%soluzione dei sistemi lineari
%definisco manualmente i campi della struttura bezier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function kur =curv2_bezier_kur_plot(bezier,np,varargin)
%Disegna la funzione curvatura di una curva 2D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti in cui valutare e disegnare i valori di curvatura
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%kur <-- valori della funzione curvatura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% n=g+1;
%Algoritmo2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function val = curv2_bezier_length(bezier)
%Calcola il valore della lunghezza di una curva di Bezier 2D
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%val <-- valore della lunghezza della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function bezier = curv2_bezier_load(filename)
%Legge una curva 2D di Bezier da file
%filename --> nome del file di estensione .db
%bezier <-- struttura di una curva di bezier:
%      bezier.deg <-- grado della curva
%      bezier.cp  <-- lista dei punti di controllo (bezier.deg+1) x2
%      bezier.ab  <-- intervallo di definizione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado 
%s',1);
%s',1);
%s',1);
%control_point
%s',1);
%s',1); 
%intervallo di definizione
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function mdppBez = curv2_bezier_offset(bezier,d,varargin)
%Determina la curva Bezier a tratti multi-degree offset approssimato
%di una curva 2D di Bezier
%bezP--> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%d   --> distanza (positiva o negativa) della curva offset dalla Bezier 
%mdppBez <-- struttura di una curva Bezier a tratti multi-degree
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%inizializzazioni
%vettore dei valori estremi della curva di Bezier
%struttura fBezier per derivata prima delle funzioni 
%componenti la curva di Bezier
% rootsx = bezier_clipping(f,TOL);
%     fprintf('Lista delle radici trovate nell''intervallo:\n');
%     fprintf('%22.15e\n',rootsx);
%struttura fBezier
% rootsy = bezier_clipping(f,TOL);
%     fprintf('Lista delle radici trovate2 nell''intervallo:\n');
%     fprintf('%22.15e\n',rootsy);
%elimina radici troppo vicine tra loro (vicine meno di 1.0e-2)
%copia della curva bezP in bez_dx

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy] = curv2_bezier_offset_plot(bezier,np,varargin)
%Disegna l'offset di una curva 2D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%d   --> distanza (positiva o negativa) della curva offset dalla Bezier
%np  --> numero di punti di valutazione
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%npx,npy <-- coordinate dei punti offset/plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1 da correggere
%bas_bernst = bernst_valder(bezier.deg,t);
%Px(:,1)=bas_bernst*bezier.cp(:,1);
%Px(:,2)=bas_bernst*bezier.cp(:,2);
%Algoritmo2
% for i=1:abs(np)
%     td(i)=norm([xp(i),yp(i)],2);
%     tx(i)=xp(i)/td(i);
%     ty(i)=yp(i)/td(i);
% end
% for i=1:abs(np)
%     plot([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],'g-')
% end
% %colore e stile linea fissi a solid e ciano
%   plot([x(i),npx(i)],[y(i),npy(i)],'c-');
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv2_bezier_plot(bezier,np,varargin)
%Disegna una curva 2D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%Px <-- punti della curva valutata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bernst = bernst(bezier.deg,mesh);
%x=bas_bernst*qx;
%y=bas_bernst*qy;
%Algoritmo2
%Chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv2_bezier_save(filename, bezier)
%Scrive una curva 2D di Bezier su file
%filename --> nome del file di estensione .db
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n', bezier.deg);
%e %e\n',bezier.cp(i,1),bezier.cp(i,2));
%e\n',bezier.ab(1));
%e\n',bezier.ab(2));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv2_bezier_tan_plot(bezier,np,varargin)
%Disegna il vettore tangente di una curva 2D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti in cui valutare e disegnare i vettori tangente
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%Px <-- vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bernst = bernst_der(g,t);
%x=bas_bernst*qx;
%y=bas_bernst*qy;
%Algoritmo2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv2_bezier_vel_plot(bezier,np,varargin)
%Disegna la funzione velocita' di una curva di Bezier 2D
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti in cui valutare e disegnare i valori velocita'
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%vel <-- valori della  funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%n=g+1;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv2_bezier_vel_val(bezier,x)
%Calcola il valore della funzione velocita' di una curva di Bezier 2D
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%x --> punto/i in cui valutare
%vel <-- valore/i della  funzione velocita' in corrispondenza di x
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy] = curv2_comb_plot(cs2name,a,b,np,varargin)
%Disegna il comb di una curva 2D
%cs2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata seconda
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%npx,npy <-- coordinate dei punti del comb e plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% for i=1:abs(np)
%     td(i)=norm([xp(i),yp(i)],2);
%     tx(i)=xp(i)/td(i);
%     ty(i)=yp(i)/td(i);
% end
% for i=1:abs(np)
%     plot([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],'g-')
% end
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [IP1P2,t1,t2]=curv2_intersect(P1,P2)
%Determina i punti di intersezione delle curve P1 e P2 e i loro parametri.
%Questa function prende in input due curve in forma parametrica di tipo
%Bézier, ppBézier, mdppBézier, spline e nurbs.
%Se viene chiamata con un solo argomento (una sola curva), vengono
%calcolate le auto intersezioni e i loro parametri.
%P1, P2 --> strutture delle curve in input dei tipi dopra elencati
%IP1P2  <-- struttura 2xn contenente le n intersezioni trovate
%t1, t2 <-- array contenenti i parametri dei punti di intersezione
%           rispettivamente per la prima e seconda curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%         a1=Ps.ab(1); b1=Ps.ab(2);
%         a1=Ps.ab(1); b1=Ps.ab(end);
%         a1=Ps.ab(1); b1=Ps.ab(end);
%         a1=Ps.knot(1); b1=Ps.knot(end);
%         a1=Ps.knot(1); b1=Ps.knot(end);
%             a2=Ps.ab(1); b2=Ps.ab(2);
%             a2=Ps.ab(1); b2=Ps.ab(end);
%             a2=Ps.ab(1); b2=Ps.ab(end);
%             a2=Ps.knot(1); b2=Ps.knot(end);
%             a2=Ps.knot(1); b2=Ps.knot(end);
%determina i tre punti (x(i),y(i)) della lista (x,y)
%piu' vicini a (x0,y0) in norma euclidea;
%ritorna le tre distanze minori (vettore vval) e i loro indici 
%nella lista dei punti (vettore vind)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function kur=curv2_kur_plot(cs2name,a,b,np,varargin)
%Disegna la funzione curvatura di una curva 2D
%cs2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata seconda
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%kur <-- valori funzione curvatura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata disegno funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function val = curv2_length(cp2name,a,b)
%Calcola la lunghezza di una curva 2D
%cp2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%a,b --> intervallo di definizione
%val <-- valore della lunghezza della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function P=curv2_mdppbezier_load(filename)
%Legge una curva 2D di Bezier a tratti multi-degree da file
%filename --> nome del file di estensione .db
%P <-- struttura formata da tre campi:
%      P.deg <-- lista dei gradi dei tratto
%      P.cp  <-- lista dei punti di controllo ncp x 2
%      P.ab  <-- partizione di [a,b]; nc + 1 elementi
%Nota: nc viene letto dal file
%      ncp = numero dei punti di controllo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %numero di curve 
%s',1);
%gradi
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv2_mdppbezier_plot(mdppbez,np,varargin)
%Disegna una curva 2D di Bezier a tratti multi-degree
%mdppbez  --> struttura di una Bezier a tratti multi-degree:
%             mdppbez.deg --> lista dei gradi della curva
%             mdppbez.cp  --> lista dei punti di controllo ncp x 2
%             mdppbez.ab  --> partizione di [a,b]; nc + 1 elementi
%np       --> numero di punti da plottare per tratto
%             se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px       <-- punti della curva valutata
%Nota: nc = numero dei tratti
%      ncp = numero dei punti di controllo
%      anche nc=length(mdppbez.ab)-1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%versione vecchia
% %numero di tratti
% nc=length(mdppbez.ab)-1;
% i1=1;
% Px=[];
% for i=1:nc
%   i2=i1+mdppbez.deg(i);
%   bezier.deg=mdppbez.deg(i);
%   bezier.cp=mdppbez.cp(i1:i2,:);
%   bezier.ab(1)= mdppbez.ab(i);
%   bezier.ab(2)= mdppbez.ab(i+1);
%   Px = curv2_bezier_plot(bezier,np,varargin{:});
%   i1=i2;
% end
% nc=length(mdppbezier.ab)-1;
% mesh=[];
% for i=1:nc
%   mesh = [mesh, linspace(mdppbezier.ab(i),mdppbezier.ab(i+1),np)];
% end
% 
% %Algoritmo2
% Px=mdppdecast_val(mdppbezier,mesh);
% 
% %Chiamata di disegno
% mesh_curv2_plot(Px(:,1),Px(:,2),varargin{:});
%  clear bezier.cp

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv2_mdppbezier_save(filename, P)
%Scrive una curva 2D di Bezier a tratti su file
%filename --> nome del file di estensione .db
%mdppbez  --> struttura formata da tre campi:
%             mdppbez.deg --> lista dei gradi della curva
%             mdppbez.cp  --> lista dei punti di controllo ncp x 2
%             mdppbez.ab  --> partizione di [a,b]; nc+1 elementi
%Nota: nc = numero dei tratti
%      ncp = numero dei punti di controllo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',nc);
%i\n',mdppbez.deg(i));
%e %e\n',mdppbez.cp(i,1),mdppbez.cp(i,2));
%e\n',mdppbez.ab(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [P,tpar] = curv2_nearest_point(x0,y0,curvP)
%Determina il punto più vicino (in norma euclidea) di una curva 2D
%ad un punto dato e il valore parametrico della curva.
%La curva in input può essere di uno qualunque dei seguenti 5 tipi:
%Bézier, ppBézier, mdppBézier, spline e nurbs.
%x0,y0  --> punto 2D
%curvP  --> struttura di una curva 2D di uno dei tipi sopra elencati
%P      <-- punto 2D della curva più vicino al punto dato
%tpar   <-- parametro della curva in corrispondenza di P
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%k contiene gli indici dei tre punti della curva più vicini al punto dato
%cerchiamo il più vicino ancora fra np punti campionati fra questi tre
%appena trovati
%determina il punto (x(i),y(i)) della lista di punti (x,y)
%piu' vicino a (x0,y0) in norma euclidea;
%ritorna la distanza minore (vval) e il suo indice 
%nella lista dei punti (vind)
%determina i tre punti (x(i),y(i)) della lista (x,y)
%piu' vicini a (x0,y0) in norma euclidea;
%ritorna le tre distanze minori (vettore vval) e i loro indici 
%nella lista dei punti (vettore vind)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv2_nurbs_comb_plot(nurbs,np,varargin)
%Disegna il comb di una curva 2D nurbs
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi
%np  --> numero di punti di valutazione per tratto
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpsspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%Algoritmo2
% for i=1:npp
%     td(i)=norm([xp(i),yp(i)],2);
%     tx(i)=xp(i)/td(i);
%     ty(i)=yp(i)/td(i);
% end
% for i=1:npp
%     plot([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],'g-')
% end
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function kur = curv2_nurbs_kur_plot(nurbs,np,varargin)
%Disegna la funzione curvatura di una curva nurbs 2D
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x2 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori di curvatura
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%kur <-- valori della funzione curvatura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv2_nurbs_vel_val(nurbs,x)
%Calcola il valore lunghezza di una curva nurbs 2D
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x2 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%val <-- valore della lunghezza della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function nurbs=curv2_nurbs_load(filename)
%Legge una curva 2D nurbs da file
%filename --> nome del file di estensione .db
%nurbs <-- struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado 
%s',1);
%5d',1);   %num. control point
%s',1);
%5d',1);    %num. nodi
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv2_nurbs_plot(nurbs,np,varargin)
%Disegna una curva 2D nurbs
%nurbs --> struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x2
%          nurbs.knot  --> lista dei nodi
%          nurbs.w --> lista dei pesi (weight)
%np --> numero di punti da plottare per ciascun tratto
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%Px <-- punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_brspline = gcw_bspl(g,knot,qw,mesh);
%x=bas_brspline*qx;
%y=bas_brspline*qy;
%Algoritmo2
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv2_nurbs_save(filename, nurbs)
%Scrive una curva 2D nurbs su file
%filename --> nome del file di estensione .db
%nurbs --> struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x2
%          nurbs.knot  --> vettore dei nodi (ncp)
%          nurbs.w --> lista dei pesi (ncp+nurbs.deg+1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',nurbs.deg);
%i\n',ncp);
%i\n',nt);
%e %e %e\n',nurbs.cp(i,1),nurbs.cp(i,2),nurbs.w(i));
%e\n',nurbs.knot(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv2_nurbs_tan_plot(nurbs,np,varargin)
%Disegna il vettore tangente di una curva 2D nurbs
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo 
%          nurbs.w   --> lista dei  pesi
%          nurbs.knot  --> vettore dei nodi
%np --> numero di punti in cui valutare e disegnare i vettori tangente
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%Px <-- vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%Algoritmo2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv2_nurbs_vel_plot(nurbs,np,varargin)
%Disegna la funzione velocita' di una curva nurbs 2D
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x2 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori velocita'
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%vel <-- valori della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv2_nurbs_vel_val(nurbs,x)
%Calcola il valore della funzione velocita' di una curva nurbs 2D
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x2 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%x --> punto/i in cui valutare 
%vel <-- valore/i della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [vecx,vecy]=curv2_offset_adapt_plot(cp2name,a,b,d,tol,varargin)
%Disegna una curva 2D offset
%cp2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%a,b --> intervallo di definizione
%d   --> distanza (positiva o negativa) della curva offset dalla curva
%tol --> tolleranza di valutazione
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%vecx,vecy <-- coordinate dei punti offset sinistra
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy] = curv2_offset_plot(cs2name,a,b,np,varargin)
%Disegna il comb di una curva 2D
%cp2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%d   --> distanza (positiva o negativa) della curva offset dalla curva
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%npx,npy <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% for i=1:abs(np)
%     td(i)=norm([xp(i),yp(i)],2);
%     tx(i)=xp(i)/td(i);
%     ty(i)=yp(i)/td(i);
% end
% for i=1:abs(np)
%     plot([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],'g-')
% end
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function tt=curv2_param(param,X,Y)
%Calcola la parametrizzazionei di una lista di punti 2D  
%param  --> scelta della parametrizzazione
%           0=uniforme, 1=centripeta, 2=corda
%X      --> vettore delle ascisse
%Y      --> vettore delle ordinate
%tt     <-- parametrizzazione della lista di punti 2D
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y]=curv2_plot(curvname,a,b,np,varargin)
%Disegna una curva 2D
%curvname --> nome del file con l'espressione parametrica della curva
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%x,y <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function ppP=curv2_ppbezierCC1_interp(Q,a,b,param)
%Calcola la struttura Bezier cubica a tratti 2D di Hermite
%di interpolazione di una lista di punti 2D 
%Q     --> lista di punti da interpolare (npunti)x2
%a,b   --> intervallo di interpolazione
%param --> scelta della parametrizzazione
%          0=uniforme, 1=centripeta, 2=corda
%ppP   <-- struttura della curva di Bezier a tratti 2D
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%parametrizzazione
%alpha=0.0;  %uniforme
%alpha=0.5;  %centripeta
%alpha=1.0;  %corda
%Calcola parametrizzazione
%fine parametrizzazione
%derivate stimate dai dati; 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function ppP=curv2_ppbezierCC1_interp_der(Q,Q1,t)
%Calcola la struttura Bezier cubica a tratti 2D di Hermite
%di interpolazione di una lista di punti 2D 
%Q     --> lista di punti da interpolare (npunti)x2
%Q1    --> lista vettori tangenti nei punti da interpolare (npunti)x2
%t     --> parametri in corrispondenza dei punti
%ppP   <-- struttura della curva 2D Bezier a tratti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function P=curv2_ppbezier_load(filename)
%Legge una curva 2D di Bezier a tratti da file
%filename --> nome del file di estensione .db
%P <-- struttura formata da tre campi:
%      P.deg <-- grado della curva o di ogni tratto
%      P.cp  <-- lista dei punti di controllo (nc*P.deg+1) x 2
%      P.ab  <-- partizione di [a,b]; nc + 1 elementi
%Nota: nc viene letto dal file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %numero di curve 
%s',1);
%5d',1); %grado 
%s',1);
%s',1);
%s',1);
%control_point
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function mdppBez = curv2_ppbezier_offset(bezier,d,varargin)
%Determina la curva Bezier a tratti multi-degree offset approssimato
%di una curva 2D di Bezier a tratti
%Attenzione: la curva ppbez in input deve essere C^1.
%ppbez --> struttura di una Bezier a tratti:
%          ppbez.deg --> grado della curva o di ogni tratto
%          ppbez.cp  --> lista dei punti di controllo (nc*ppbez.deg+1) x 2
%          ppbez.ab  --> partizione di [a,b]; nc + 1 elementi
%d     --> distanza (positiva o negativa) della curva offset dalla Bezier 
%mdppBez <-- struttura di una curva Bezier a tratti multi-degree
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%inizializzazioni
%vettore dei valori estremi della curva di Bezier
%struttura fBezier per derivata prima delle funzioni 
%componenti la curva di Bezier
% rootsx = bezier_clipping(f,TOL);
%     fprintf('Lista delle radici trovate nell''intervallo:\n');
%     fprintf('%22.15e\n',rootsx);
%struttura fBezier
% rootsy = bezier_clipping(f,TOL);
%     fprintf('Lista delle radici trovate2 nell''intervallo:\n');
%     fprintf('%22.15e\n',rootsy);
%elimina radici troppo vicine tra loro (vicine meno di 1.0e-2)
%copia della curva bezP in bez_dx

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px = curv2_ppbezier_plot(ppbez,np,varargin)
%Disegna una curva 2D spline
%ppbez --> struttura di una Bezier a tratti:
%          ppbez.deg --> grado della curva o di ogni tratto
%          ppbez.cp  --> lista dei punti di controllo (nc*ppbez.deg+1) x 2
%          ppbez.ab  --> partizione di [a,b]; nc + 1 elementi
%np    --> numero di punti da plottare per tratto
%          se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px    <-- punti di valutazione
%Nota: nc=(ncp-1)/ppbez.deg, con ncp numero dei punti di controllo
%      o anche nc=length(ppbez.ab)-1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%definizioni alternative
% [ncp,m]=size(ppbez.cp);
% nc=(ncp-1)/ppbez.deg;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv2_ppbezier_save(filename, P)
%Scrive una curva 2D di Bezier a tratti su file
%filename --> nome del file di estensione .db
%P --> struttura formata da tre campi:
%      P.deg <-- grado della curva o di ogni tratto
%      P.cp  <-- lista dei punti di controllo (nc*P.deg+1) x 2
%      P.ab  <-- partizione di [a,b]; nc + 1 elementi
%Nota: nc=numero dei tratti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',nc);
%i\n',P.deg);
%e %e\n',P.cp(i,1),P.cp(i,2));
%e\n',P.ab(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function ppbezier=curv2_spline2ppbezier(spline)
%Converte una curva 2D spline in una curva di Bezier a tratti
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x2 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%ppbezier  <-- struttura della curva 2D di Bezier a tratti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv2_splineCC2_der_interp(Q,param,Qp)
%Calcola la spline cubica di interpolazione con derivate agli 
%estremi di una lista di punti 2D e restituisce la struttura 
%spline della curva
%Q           --> lista di punti da interpolare (npunti)x2
%param       --> scelta della parametrizzazione
%                -1=parametrizzazione delle ascisse dei punti Q
%                0=uniforme, 1=centripeta, 2=corda
%Qp          --> lista delle derivate negli estremi
%spline      <-- struttura della curva spline 2D
%       spline.deg  <-- grado della spline
%       spline.knot <-- partizione nodale estesa
%       spline.cp   <-- vettore dei control point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%calcolo della parametrizzazione
%calcolo delle derivate
%calcolo della partizione nodale
%calcolo dei coefficienti
% c=gc_bspl(g,t,tt(2:n-1));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv2_splineCC2_nak_interp(Q,param)
%Calcola la spline cubica di interpolazione not-a-knot di una 
%lista di punti 2D e restituisce la struttura spline della curva
%Q           --> lista di punti da interpolare (npunti)x2
%param       --> scelta della parametrizzazione
%                -1=parametrizzazione delle ascisse dei punti Q
%                0=uniforme, 1=centripeta, 2=corda
%spline      <-- struttura della curva spline 2D
%       spline.deg  <-- grado della spline
%       spline.knot <-- partizione nodale estesa
%       spline.cp   <-- vettore dei control point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%calcolo della parametrizzazione
%calcolo della partizione nodale
% c=gc_bspl(3,t,tt(2:n-1));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv2_splineCC2_nat_interp(Q,param)
%Calcola la spline cubica di interpolazione naturale di una 
%lista di punti 2D e restituisce la struttura spline della curva
%Q           --> lista di punti da interpolare (npunti)x2
%param       --> scelta della parametrizzazione
%                -1=parametrizzazione delle ascisse dei punti Q
%                0=uniforme, 1=centripeta, 2=corda
%spline      <-- struttura della curva spline 2D
%       spline.deg  <-- grado della spline
%       spline.knot <-- partizione nodale estesa
%       spline.cp   <-- vettore dei control point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%calcolo della parametrizzazione
%calcolo della partizione nodale
%calcolo dei coefficienti
% cc=gc_bspl(g,t,tt(2:n-1));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv2_splineCC2_per_interp(Q,param)
%Calcola la spline Cubica C2 di interpolazione periodica di una lista 
%di punti 2D e restituisce la struttura della curva spline soluzione
%Q           --> lista di punti da interpolare (npunti)x2
%param       --> scelta della parametrizzazione
%                -1=parametrizzazione delle ascisse dei punti Q
%                 0=uniforme, 1=centripeta, 2=corda
%spline <-- struttura di una curva spline:
%          spline.deg <-- grado della curva
%          spline.cp  <-- lista dei punti di controllo (ncp)x2
%          spline.knot <-- vettore dei nodi (ncp+g+1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%grado della spline
%calcolo della parametrizzazione
%calcolo della partizione nodale periodica
%calcolo dei matrice dei coefficienti (B-spline nei punti di interp.)
% c=gc_bspl(g,t,t(4:n+2));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv2_spline_comb_plot(spline,np,ls)
%Disegna il comb di una curva 2D spline
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo 
%          spline.knot  --> vettore dei nodi
%np  --> numero di punti di valutazione per tratto
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpsspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%Algoritmo2
% for i=1:npp
%     td(i)=norm([xp(i),yp(i)],2);
%     tx(i)=xp(i)/td(i);
%     ty(i)=yp(i)/td(i);
% end
% for i=1:npp
%     plot([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],'g-')
% end
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function kur = curv2_spline_kur_plot(spline,np,varargin)
%Disegna la funzione curvatura di una curva Spline 2D
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x2 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori di curvatura
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%kur <-- valori della funzione curvatura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function val = curv2_spline_length(spline)
%Calcola il valore della lunghezza di una curva Spline 2D
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x2 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%val <-- valore della lunghezza della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline = curv2_spline_load(filename)
%Legge una curva 2D spline da file
%filename --> nome del file di estensione .db
%spline <-- struttura di una curva spline:
%          spline.deg <-- grado della curva
%          spline.cp  <-- lista dei punti di controllo (ncp)x2 
%          spline.knot <-- vettore dei nodi (ncp+g+1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado 
%s',1);
%5d',1);   %num. control point
%s',1);
%5d',1);    %num. nodi
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv2_spline_plot(spline,np,varargin)
%Disegna una curva 2D spline
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x2 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti da plottare per ciascun tratto
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%Px <-- punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspline = gc_bspl(spline.deg,spline.knot,mesh);
%x=bas_bspline*qx;
%y=bas_bspline*qy;
%Algoritmo2
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv2_spline_save(filename, spline)
%Scrive una curva 2D spline su file
%filename --> nome del file di estensione .db
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x2 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',spline.deg);
%i\n',ncp);
%i\n',nt);
%e %e\n',spline.cp(i,1),spline.cp(i,2));
%e\n',spline.knot(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv2_spline_tan_plot(spline,np,varargin)
%Disegna il vettore tangente di una curva 2D spline
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo 
%          spline.knot  --> vettore dei nodi
%np --> numero di punti in cui valutare e disegnare i vettori tangente
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%Px <-- vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%Algoritmo2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv2_spline_vel_plot(spline,np,varargin)
%Disegna la funzione velocita' di una curva Spline 2D
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x2 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori velocita'
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%vel <-- valori della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv2_spline_vel_val(spline,x)
%Calcola il valore della funzione velocita' di una curva Spline 2D
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x2 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%x --> punto/i in cui valutare
%vel <-- valore/i della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xp,yp]=curv2_tan_plot(cp2name,a,b,np,varargin)
%Disegna i vettori tangente di una curva 2D
%cp2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%xp,yp <-- coordinate dei vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% for i=1:abs(np)
%     td(i)=norm([xp(i),yp(i)],2);
%     tx(i)=xp(i)/td(i);
%     ty(i)=yp(i)/td(i);
% end
%    plot([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],ls)
%    plot([x(i),x(i)+xp(i)],[y(i),y(i)+yp(i)],ls)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y]=curv2_trans_plot(curvname,a,b,np,M,varargin)
%Disegna una curva 2D dopo aver applicato la trasformazione M 
%curvname --> nome del file con l'espressione parametrica della curva
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%M  --> matrice di trasformazione 3x3
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%x,y <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv2_vel_plot(cp2name,a,b,np,varargin)
%Disegna la funzione velocita' di una curva 2D
%cp2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare, in ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%vel <-- valori della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function val = curv2_vel_val(cp2name,a,b,x)
%Calcola il valore della funzione velocita' di una curva 2D
%cp2name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%x --> punto/i in cui valutare
%vel <-- valore/i della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz]=curv3_bezier_comb_plot(bezier,np,varargin)
%Disegna il comb di una curva 3D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%np  --> numero di punti di valutazione
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bernst = bernst_der2(bezier.deg,mesh);
%x=bas_bernst*qx;
%y=bas_bernst*qy;
%z=bas_bernst*qz;
%Algoritmo2
%vettore binormale alla curva in ogni punto e calcolo valore curvatura
%vettore normale alla curva in ogni punto
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function bezier = curv3_bezier_interp(Q,a,b,param)
%Calcola la curva 3D di Bezier di interpolazione dei punti Q
%Q --> lista dei punti 3D di interpolazione (g+1)x3
%a,b --> intervallo di interpolazione
% param --> scelta della parametrizzazione
%           0=uniforma, 1=centripeta, 2=corda
%bezier <-- struttura della curva 3D di Bezier :
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x3
%          bezier.ab  --> intervallo di definizione [a b]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% bma=b-a;
%parametrizzazione
%alpha=0.0;  %uniforme
%alpha=0.5;  %centripeta
%alpha=1.0;  %corda
%Calcola parametrizzazione
%fine parametrizzazione
%forma di Bernstein (Matrice delle funzioni base nei punti)
%tt=(t-a)./bma;
%soluzione dei sistemi lineari
%definisco manualmente i campi della struttura bezier
% function P=curv3_bezier_interp(Q,a,b,param)
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %function P=curv3_bezier_interp(Q,a,b,param)
% %Calcola la curva 3D di Bezier di interpolazione dei punti Q
% %Q --> lista dei punti 3D di interpolazione (g+1)x3
% %a,b --> intervallo di interpolazione
% % param --> scelta della parametrizzazione
% %           0=uniforma, 1=centripeta, 2=corda
% %P <-- punti di controllo della curva 3D di Bezier (g+1)x3
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% cqx=Q(:,1);
% cqy=Q(:,2);
% cqz=Q(:,3);
% m=length(cqx);
% n=m-1;
% bma=b-a;
% 
% %parametrizzazione
% %alpha=0.0;  %uniforme
% %alpha=0.5;  %centripeta
% %alpha=1.0;  %corda
% alpha=0.5*param;
% %Calcola parametrizzazione
%  tau(1)=0;
%  for i=2:m
%    tau(i)=tau(i-1)+sqrt((cqx(i)-cqx(i-1)).^2+(cqy(i)-cqy(i-1)).^2+(cqz(i)-cqz(i-1)).^2).^alpha;
%  end
%  t(1)=0;
%  for i=2:m
%    t(i)=tau(i)/tau(m);
%  end
% %fine parametrizzazione
% 
% %forma di Bernstein (Matrice delle funzioni base nei punti)
% %tt=(t-a)./bma;
% B=bernst(n,t);
% 
% %soluzione dei sistemi lineari
% P=zeros(m,3);
% P(:,1)=B\cqx;
% P(:,2)=B\cqy;
% P(:,3)=B\cqz;
% 
% end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function kur=curv3_bezier_kur_plot(bezier,np,varargin)
%Disegna la funzione curvatura di una curva 2D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (g+1)x2
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti in cui valutare e disegnare i valori di curvatura
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%kur <-- valori della funzione curvatura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo2
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function val = curv3_bezier_length(bezier)
%Calcola il valore della lunghezza di una curva di Bezier 3D
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x2
%          bezier.ab  --> intervallo di definizione
%val <-- valore della lunghezza della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function bezier = curv3_bezier_load(filename)
%Legge una curva 3D di Bezier da file
%filename --> nome del file di estensione .db
%bezier <-- struttura di una curva di bezier:
%      bezier.deg <-- grado della curva
%      bezier.cp  <-- lista dei punti di controllo (bezier.deg+1) x3
%      bezier.ab  <-- intervallo di definizione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado 
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv3_bezier_plot(bezier,np,varargin)
%Disegna una curva 3D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x3
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px <-- punti di valutazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bernst = bernst(bezier.deg,mesh);
%x=bas_bernst*qx;
%y=bas_bernst*qy;
%z=bas_bernst*qz;
%Algoritmo2
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv3_bezier_save(filename, bezier)
%Scrive una curva 3D di Bezier su file
%filename --> nome del file di estensione .db
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x3
%          bezier.ab  --> intervallo di definizione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',bezier.deg);
%e %e %e\n',bezier.cp(i,1),bezier.cp(i,2),bezier.cp(i,3));
%e\n',bezier.ab(1));
%e\n',bezier.ab(2));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv3_bezier_tan_plot(bezier,np,varargin)
%Disegna il vettore tangente di una curva 3D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x3
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti in cui valutare e disegnare i vettori tangente
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px <-- vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bernst = bernst_der(bezier.deg,mesh);
%x=bas_bernst*qx;
%y=bas_bernst*qy;
%z=bas_bernst*qz;
%Algoritmo2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz] = curv3_bezier_tcomb_plot(bezier,np,varargin)
%Disegna il torsion comb di una curva 3D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x3
%          bezier.ab  --> intervallo di definizione
%np  --> numero di punti di valutazione
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npz <-- coordinate valori plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bernst = bernst_der2(bezier.deg,bezier.knot);
%x=bas_bernst*qx;
%y=bas_bernst*qy;
%z=bas_bernst*qz;
%Algoritmo2
%vettore binormale alla curva in ogni punto e calcolo valore curvatura
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function tau = curv3_bezier_tor_plot(bezier,np,varargin)
%Disegna la funzione torsione di una curva 3D di Bezier
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x3
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti in cui valutare e disegnare i valori di torsione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%tor <-- valori della funzione torsione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv3_bezier_vel_plot(bezier,np,varargin)
%Disegna la funzione velocita' di una curva di Bezier 3D
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x3
%          bezier.ab  --> intervallo di definizione
%np --> numero di punti in cui valutare e disegnare i valori velocita'
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%vel <-- valori della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo2
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv3_bezier_vel_val(bezier,x)
%Calcola il valore della funzione velocita' di una curva di Bezier 3D
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (bezier.deg+1)x3
%          bezier.ab  --> intervallo di definizione
%x --> punto/i in cui valutare
%vel <-- valore/i della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz] = curv3_comb_plot(cs3name,a,b,np,varargin)
%Disegna il comb di una curva 3D
%cs3name --> nome del file con l'espressione parametrica
%            della curva fino alla derivata seconda
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%vettore binormale alla curva in ogni punto e calcolo valore curvatura
%vettore normale alla curva in ogni punto
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv3_frenetframe_plot(cs3name,a,b,np)
%Disegna il Frenet Frame di una curva 3D (T,N,B) utilizzando la terna di
%colori r (tangnte) g (normale) b (binormale)
%cs3name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata seconda
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    plot3([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],[z(i),z(i)+tz(i)],'g-')
%vettore binormale alla curva in ogni punto
%    plot3([x(i),x(i)+bx(i)],[y(i),y(i)+by(i)],[z(i),z(i)+bz(i)],'r-')
%vettore normale alla curva in ogni punto
%    plot3([x(i),x(i)+nx(i)],[y(i),y(i)+ny(i)],[z(i),z(i)+nz(i)],'b')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function bezier = curv3_from_bezier_surf(surfbezier, fuv, uv)
%Determina una isocurva 3D di Bezier da una superficie 3D di Bezier
%surfbezier --> struttura di una superficie di Bezier:
%      surfbezier.deguv --> gradi della superficie in u e in v
%      surfbezier.cp --> griglia dei punti di controllo (degu+1)x(degv+1)x3
%      surfbezier.ab  --> intervallo di definizione in u
%      surfbezier.cd  --> intervallo di definizione in v
%fuv   --> direzione u o v; 1=estrae curva in u; 2=estrae curva in v
%uv    --> parametro u o v (a seconda di fuv) 
%          fuv=1 allora uv deve contenere un valore v=costante
%          fuv=2 allora uv deve contenere un valore u=costante
%bezier <-- struttura contenente l'isocurva di Bezier risultante:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo
%          bezier.ab  --> intervallo di definizione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%direzione di valutazione
%Algoritmo2: usa de Casteljau
%calcola ncpv curve in u:=uv
%struttura da restituire
%Algoritmo2: usa de Casteljau
%calcola ncpu curve in v:=uv
%struttura da restituire

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curvnurbs=curv3_from_nurbs_surf(surfnurbs, fuv, uv)
%Determina una isocurva 3D nurbs da una superficie 3D nurbs
%surfnurbs --> struttura di una superficie nurbs:
%  surfnurbs.deguv --> vettore dei gradi della superficie in u e in v
%  surfnurbs.cp    --> griglia dei punti di controllo
%  surfnurbs.w     --> griglia dei pesi
%  surfnurbs.ku    --> vettore dei knot in u
%  surfnurbs.kv    --> vettore dei knot in v
%fuv   --> direzione u o v; 1=estrae curva in u; 2=estrae curva in v
%uv    --> parametro u o v (a seconda di fuv)
%          fuv=1 allora uv deve contenere un valore v=costante
%          fuv=2 allora uv deve contenere un valore u=costante
%nurbs <-- struttura contenente l'isocurva nurbs risultante:
%          nurbs.deg   --> grado della curva
%          nurbs.cp    --> lista dei punti di controllo
%          nurbs.w     --> lista dei pesi
%          nurbs.knot  --> vettore dei knot
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%direzione di valutazione
%Algoritmo2: usa de Boor
%calcola ncpu curve in v per v:=uv
%struttura da restituire
%Algoritmo2: usa de Boor
%calcola ncpv curve in u per u:=uv
%struttura da restituire

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curvspline=curv3_from_spline_surf(gu, gv, P, u, v, fuv, uv)
%Determina una isocurva 3D spline da una superficie 3D spline
%surfspline --> struttura di una superficie spline:
%  surfspline.deguv --> vettore dei gradi della superficie in u e in v
%  surfspline.cp    --> griglia dei punti di controllo
%  surfspline.ku    --> vettore dei knot in u
%  surfspline.kv    --> vettore dei knot in v
%fuv   --> direzione u o v; 1=estrae curva in u; 2=estrae curva in v
%uv    --> parametro u o v (a seconda di fuv)
%          fuv=1 allora uv deve contenere un valore v=costante
%          fuv=2 allora uv deve contenere un valore u=costante
%spline <-- struttura contenente l'isocurva spline risultante:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo
%          spline.knot  --> vettore dei knot
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%direzione di valutazione
%Algoritmo2: usa de Boor
%calcola ncpu curve in v per v:=uv
%struttura da restituire
%Algoritmo2: usa di de Boor
%calcola ncpv curve in u per u:=uv
%struttura da restituire

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz] = curv3_from_surf_comb_plot(surfname,a,b,np,fuv,uv,varargin)
%Disegna il comb di una isocurva 3D di una superficie 3D
%surfname --> nome del file della superficie parametrica
%a,b   --> intervallo di definizione
%np    --> numero di punti di valutazione
%          se negativo si valuta, ma non si disegna
%fuv   --> direzione u o v; 1: estrae curva in u; 2: in v
%uv    --> parametro u o v (a seconda di fuv) 
%          fuv=1 allora uv deve contenere un valore v=costante
%          fuv=2 allora uv deve contenere un valore u=costante
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    disp([x(i),y(i),z(i),xp(i),yp(i),zp(i),xs(i),ys(i),zs(i)]);
%    disp([x(i),y(i),z(i),xp(i),yp(i),zp(i),xs(i),ys(i),zs(i)]);
%vettore binormale alla curva in ogni punto e calcolo valore cyrvatura
%vettore normale alla curva in ogni punto
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=curv3_from_surf_plot(surfname,a,b,np,fuv,uv,varargin)
%Disegna una isocurva di una superficie 3D
%surfname --> nome del file della superficie parametrica
%a,b   --> intervallo di definizione
%np    --> numero di punti da plottare
%          se negativo si valuta, ma non si disegna
%fuv   --> direzione u o v; 1: estrae curva in u; 2: in v
%uv    --> parametro u o v (a seconda di fuv) 
%          fuv=1 allora uv deve contenere un valore v=costante
%          fuv=2 allora uv deve contenere un valore u=costante
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%x,y,z <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xp,yp,zp] = curv3_from_surf_tan_plot(surfname,a,b,np,fuv,uv,varargin)
%Disegna i vettori tangenti di una isocurva 3D di una superficie 3D
%surfname --> nome del file della superficie parametrica
%a,b   --> intervallo di definizione
%np    --> numero di punti da plottare
%          se negativo si valuta, ma non si disegna
%fuv   --> direzione u o v; 1: estrae curva in u; 2: in v
%uv    --> parametro u o v (a seconda di fuv) 
%          fuv=1 allora uv deve contenere un valore v=costante
%          fuv=2 allora uv deve contenere un valore u=costante
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%xp,yp,zp <-- coordinate dei vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    disp([x(i),y(i),z(i),xp(i),yp(i),zp(i)]);
%    disp([x(i),y(i),z(i),xp(i),yp(i),zp(i)]);
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function kur = curv3_kur_plot(cs3name,a,b,np,varargin)
%Disegna la funzione curvatura di una curva 3D
%cs3name --> nome del file con l'espressione parametrica
%            della curva fino alla derivata seconda
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%kur <-- valori della funzione curvatura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function val = curv3_length(cp3name,a,b)
%Calcola la lunghezza di una curva 3D
%cp3name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%a,b --> intervallo di definizione
%val <-- valore della lunghezza della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function P=curv3_mdppbezier_load(filename)
%Legge una curva 3D di Bezier a tratti da file
%filename --> nome del file di estensione .db
%P <-- struttura formata da tre campi:
%      P.deg <-- lista dei gradi dei tratto
%      P.cp  <-- lista dei punti di controllo ncp x 3
%      P.ab  <-- partizione di [a,b]; nc + 1 elementi
%Nota: nc viene letto dal file
%      ncp = numero dei punti di controllo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %numero di curve 
%s',1);
%s',1);
%gradi
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px = curv3_mdppbezier_plot(ppbez,np,varargin)
%Disegna una curva 3D Bezier a tratti
%ppbez --> struttura di una Bezier a tratti:
%          ppbez.deg --> lista dei gradi della curva
%          ppbez.cp  --> lista dei punti di controllo ncpx3
%          ppbez.ab  --> partizione di [a,b]; nc + 1 elementi
%np    --> numero di punti da plottare per tratto
%          se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px    <-- punti di valutazione
%Nota: nc=length(ppbez.ab)-1
%      ncp = numero dei punti di controllo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% nc=length(ppbez.ab)-1;
% i1=1;
% Px=[];
% for i=1:nc
%   i2=i1+ppbez.deg(i);
%   Px = curv3_bezier_plot(ppbez.deg,ppbez.cp(i1:i2,:),ppbez.ab(i),ppbez.ab(i+1),np,varargin{:});
%   i1=i2;
% end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv3_mdppbezier_save(filename, P)
%Scrive una curva 3D di Bezier a tratti su file
%filename --> nome del file di estensione .db
%P --> struttura formata da tre campi:
%      P.deg --> lista dei gradi della curva
%      P.cp  --> lista dei punti di controllo ncp x 3
%      P.ab .--> partizione di [a,b]; nc + 1 elementi
%Nota: nc = numero dei tratti
%      ncp = numero dei punti di controllo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',nc);
%i\n',P.deg(i));
%e %e\n',P.cp(i,1),P.cp(i,2),P.cp(i,3));
%e\n',P.ab(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz] = curv3_nurbs_comb_plot(nurbs,np,varargin)
%Disegna il comb di una curva 3D nurbs
%nurbs --> struttura formata di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x3 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%np  --> numero di punti di valutazione per tratto
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpsspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%z=bas_bspl*qz;
%Algoritmo2
%vettore binormale alla curva in ogni punto e calcolo valore curvatura
%vettore normale alla curva in ogni punto
% for i=1:np
%     plot3([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],[z(i),z(i)+tz(i)],'g-')
% end
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function kur = curv3_nurbs_kur_plot(nurbs,np,varargin)
%Disegna la funzione curvatura di una curva 3D nurbs
%nurbs --> struttura formata di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x3 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori di curvatura
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%kur <-- valori della funzione curvatura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv3_nurbs_vel_val(nurbs,x)
%Calcola il valore lunghezza di una curva nurbs 3D
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x3 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%val <-- valore della lunghezza della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [g, P, W t]=curv3_nurbs_load(filename)
%Legge una curva 3D nurbs da file
%filename --> nome del file di estensione .db
%nurbs <-- struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado 
%s',1);
%5d',1);   %num. control point
%s',1);
%5d',1);    %num. nodi
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv3_nurbs_plot(nurbs,np,varargin)
%Disegna una curva 3D nurbs
%nurbs --> struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%np --> numero di punti da plottare per ciascun tratto
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px <-- punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%rappresentazione grafica di una curva di Bezier 2D
%non e' necessario prevedere [a,b] come input, infatti
%sara' per convenzione a=knot(g+1) e b=knot(end-g)
%Algoritmo1
%bas_brspline = gcw_bspl(g,knot,w,mesh);
%x=bas_brspline*qx;
%y=bas_brspline*qy;
%z=bas_brspline*qz;
%Algoritmo2
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv3_nurbs_save(filename, nurbs)
%Scrive una curva 3D nurbs su file
%filename --> nome del file di estensione .db
%nurbs --> struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',nurbs.deg);
%i\n',ncp);
%i\n',nt);
%e %e %e %e\n',nurbs.cp(i,1),nurbs.cp(i,2),nurbs.cp(i,3),nurbs.cp(i));
%e\n',nurbs.knot(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv3_nurbs_tan_plot(nurbs,np,varargin)
%Disegna il vettore tangente di una curva 3D spline
%nurbs --> struttura formata di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x3 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%np   --> numero di punti in cui valutare e disegnare i vettori tangente
%         se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px   <-- vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%Algoritmo2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz] = curv3_nurbs_tcomb_plot(nurbs,np,varargin)
%Disegna il torsion comb di una curva 3D nurbs
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x3 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%np  --> numero di punti di valutazione per tratto
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npx <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpsspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%z=bas_bspl*qz;
%Algoritmo2
%vettore binormale alla curva in ogni punto e calcolo valore curvatura
%colore e stile linea fissi a solid e magenta
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function tau =curv3_nurbs_tor_plot(g,P,a,b,np,varargin)
%Disegna la funzione torsione di una curva 3D nurbs
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x3 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori di torsione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%tou <-- valori della funzione torsione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv3_nurbs_vel_plot(nurbs,np,varargin)
%Disegna la funzione velocita' di una curva nurbs 3D
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x2 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori velocita'
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%vel <-- valori della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function x = curv3_nurbs_vel_val(nurbs,x)
%Calcola il valore della funzione velocita' di una curva nurbs 3D
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp)x2 
%          nurbs.w   --> lista dei pesi
%          nurbs.knot  --> vettore dei nodi (ncp+g+1)
%x --> punto/i in cui valutare 
%td <-- valore/i della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function tt=curv3_param(Q,param)
%Calcola la parametrizzazionedi una lista di punti 3D 
%Q      --> matrice dei punti da parametrizzare (npuntix3)
%param  --> scelta della parametrizzazione
%           0=uniforme, 1=centripeta, 2=corda
%tt     <-- parametrizzazione della lista di punti 3D
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=curv3_plot(curvname,a,b,np,varargin)
%Disegna una curva3D
%curvname --> nome del file con l'espressione parametrica della curva
%a,b --> intervallo di definizione
%np  --> numero di punti di valutazione
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%x,y,z <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamta di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function ppP=curv3_ppbezierCC1_interp(Q,a,b,param)
%Calcola la struttura Bezier cubica a tratti 3D di Hermite
%di interpolazione di una lista di punti 3D 
%Q     --> lista di punti da interpolare (npunti)x3
%a,b   --> intervallo di interpolazione
%param --> scelta della parametrizzazione
%          0=uniforma, 1=centripeta, 2=corda
%ls    --> line specification
%ppP   <-- struttura della curva di Bezier a tratti 3D
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%parametrizzazione
%alpha=0.0;  %uniforme
%alpha=0.5;  %centripeta
%alpha=1.0;  %corda
%Calcola parametrizzazione
%fine parametrizzazione
%derivate stimate dai dati; 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function P=curv3_ppbezier_load(filename)
%Legge una curva 3D di Bezier a tratti da file
%filename --> nome del file di estensione .db
%P <-- struttura formata da tre campi:
%      P.deg <-- grado di ogni tratto
%      P.cp  <-- lista dei punti di controllo (nc*P.deg+1) x 3
%      P.ab  <-- partizione di [a,b]; nc + 1 elementi
%Nota: nc viene letto dal file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %numero di curve 
%s',1);
%5d',1); %grado 
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px = curv3_ppbezier_plot(ppbez,np,varargin)
%Disegna una curva 3D Bezier a tratti
%ppbez --> struttura di una Bezier a tratti:
%          ppbez.deg --> grado della curva o di ogni tratto
%          ppbez.cp  --> lista dei punti di controllo (nc*ppbez.deg+1) x 3
%          ppbez.ab  --> partizione di [a,b]; nc + 1 elementi
%np    --> numero di punti da plottare per tratto
%          se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px    <-- punti di valutazione
%Nota: nc=(ncp-1)/ppbez.deg, con ncp numero dei punti di controllo
%      o anche nc=length(ppbez.ab)-1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%[ncp,m]=size(ppbez.cp);
%nc=(ncp-1)/ppbez.deg;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv3_ppbezier_save(filename, P)
%Scrive una curva 3D di Bezier a tratti su file
%filename --> nome del file di estensione .db
%P --> struttura formata da tre campi:
%      P.deg <-- grado della curva o di ogni tratto
%      P.cp  <-- lista dei punti di controllo (nc*P.deg+1) x 2
%      P.ab  <-- partizione di [a,b]; nc + 1 elementi
%Nota: nc=numero dei tratti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',nc);
%i\n',P.deg);
%e %e\n',P.cp(i,1),P.cp(i,2),P.cp(i,3));
%e\n',P.ab(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function ppbezier=curv3_spline2ppbezier(spline)
%Converte una curva 2D spline in una curva di Bezier a tratti
%spline --> struttura formata di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%ppbezier  <-- struttura della curva 3D di Bezier a tratti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% a=spline.knot(spline.deg+1);
% b=spline.knot(end-spline.deg);
% i1=1;
% ppbezier.ab(1)=a;
%ppbezier.ab(i,1)=a;
%ppbezier.ab(i+1)=t_single(i);
%ppbezier.ab(nt_s+2)=b;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv3_splineCC2_der_interp(Q,param,Qp)
%Calcola la spline cubica di interpolazione con derivate agli estremi 
%di una lista di punti 3D e restituisce la struttura spline della curva
%Q           --> lista di punti da interpolare (npunti)x3
%param       --> scelta della parametrizzazione
%                0=uniforme, 1=centripeta, 2=corda
%Qp          --> derivate agli estremi 
%spline      <-- struttura della curva spline 3D
%       spline.deg  <-- grado della spline
%       spline.knot <-- partizione nodale estesa
%       spline.cp   <-- vettore dei control point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%calcolo della parametrizzazione
%calcolo delle derivate
%calcolo della partizione nodale
%calcolo dei coefficienti
% px(1)=X(1);
% px(2)=1./3.*dx(1).*(tt(2)-tt(1))+X(1);
% px(n+1)=X(n)-1./3.*dx(length(dx)).*(tt(n)-tt(n-1));
% px(n+2)=X(n);
% py(1)=Y(1);
% py(2)=1./3.*dy(1).*(tt(2)-tt(1))+Y(1);
% py(n+1)=Y(n)-1./3.*dy(length(dy)).*(tt(n)-tt(n-1));
% py(n+2)=Y(n);
% pz(1)=Z(1);
% pz(2)=1./3.*dz(1).*(tt(2)-tt(1))+Z(1);
% pz(n+1)=Z(n)-1./3.*dz(length(dz)).*(tt(n)-tt(n-1));
% pz(n+2)=Z(n);
% if (n>1)
%   c=gc_bspl(g,t,tt(2:n-1));
%   X(2)=X(2)-px(2).*c(1,2);
%   X(n-1)=X(n-1)-px(n+1).*c(n-2,n+1);
%   Y(2)=Y(2)-py(2).*c(1,2);
%   Y(n-1)=Y(n-1)-py(n+1).*c(n-2,n+1);
%   Z(2)=Z(2)-pz(2).*c(1,2);
%   Z(n-1)=Z(n-1)-pz(n+1).*c(n-2,n+1);
%   c=c(:,3:n);
%   px(3:n)=c\X(2:n-1)';
%   py(3:n)=c\Y(2:n-1)';
%   pz(3:n)=c\Z(2:n-1)';
% end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv3_splineCC2_nak_interp(Q,param)
%Calcola la spline cubica di interpolazione  not-a-knot di una 
%lista di punti 3D e restituisce la struttura spline della curva
%Q           --> lista di punti da interpolare (npunti)x3
%param       --> scelta della parametrizzazione
%                0=uniforme, 1=centripeta, 2=corda
%spline      <-- struttura della curva spline 3D
%       spline.deg  <-- grado della spline
%       spline.knot <-- partizione nodale estesa
%       spline.cp   <-- vettore dei control point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%calcolo della parametrizzazione
%calcolo della partizione nodale
%calcolo dei coefficienti
% px(1)=X(1);
% px(n)=X(n);
% py(1)=Y(1);
% py(n)=Y(n);
% pz(1)=Z(1);
% pz(n)=Z(n);
% c=gc_bspl(g,t,tt(2:n-1));
% X(2)=X(2)-px(1).*c(1,1);
% X(n-1)=X(n-1)-px(n).*c(n-2,n);
% Y(2)=Y(2)-py(1).*c(1,1);
% Y(n-1)=Y(n-1)-py(n).*c(n-2,n);
% Z(2)=Z(2)-pz(1).*c(1,1);
% Z(n-1)=Z(n-1)-pz(n).*c(n-2,n);
% c=c(:,2:n-1);
% px(2:n-1)=c\X(2:n-1)';
% py(2:n-1)=c\Y(2:n-1)';
% pz(2:n-1)=c\Z(2:n-1)';

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv3_splineCC2_nat_interp(Q,param)
%Calcola la spline cubica di interpolazione naturale di una 
%lista di punti 3D e restituisce la struttura spline della curva
%Q           --> lista di punti da interpolare (npunti)x3
%param       --> scelta della parametrizzazione
%                0=uniforme, 1=centripeta, 2=corda
%spline      <-- struttura della curva spline 3D
%       spline.deg  <-- grado della spline
%       spline.knot <-- partizione nodale estesa
%       spline.cp   <-- vettore dei control point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%calcolo della parametrizzazione
%calcolo della partizione nodale
%calcolo dei coefficienti
% px(1)=X(1);
% px(n+2)=X(n);
% py(1)=Y(1);
% py(n+2)=Y(n);
% pz(1)=Z(1);
% pz(n+2)=Z(n);
% c=zeros(n);
% if (n>1)
%   cc=gc_bspl(g,t,tt(2:n-1));
%   c(2:n-1,:)=cc(:,2:n+1); 
%   c(1,1)=2*tt(1)-tt(2)-tt(3);
%   c(1,2)=tt(2)-tt(1);
%   c(1,3:n)=0;
%   c(n,n-1)=tt(n)-tt(n-1);
%   c(n,n)=tt(n-2)+tt(n-1)-2*tt(n);
%   X(1)=px(1)*(tt(1)-tt(3));
%   X(n)=px(n+2)*(tt(n-2)-tt(n));
%   Y(1)=py(1)*(tt(1)-tt(3));
%   Y(n)=py(n+2)*(tt(n-2)-tt(n));
%   Z(1)=pz(1)*(tt(1)-tt(3));
%   Z(n)=pz(n+2)*(tt(n-2)-tt(n));
% 
%   q=c\X';
%   px(2:n+1)=q(1:n);
%   
%   w=c\Y';
%   py(2:n+1)=w(1:n);
%   
%   e=c\Z';
%   pz(2:n+1)=e(1:n);
% end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv3_splineCC2_per_interp(Q,param)
%Calcola la spline cubica di interpolazione periodica di una 
%lista di punti 3D e restituisce la struttura spline della curva
%Q           --> lista di punti da interpolare (npunti)x3
%param       --> scelta della parametrizzazione
%                0=uniforme, 1=centripeta, 2=corda
%spline      <-- struttura della curva spline 3D
%       spline.deg  <-- grado della spline
%       spline.knot <-- partizione nodale estesa
%       spline.cp   <-- vettore dei control point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%calcolo della parametrizzazione
%calcolo della partizione nodale
%calcolo dei coefficienti
% c=gc_bspl(g,t,t(4:n+2));
% c(1,n)=c(1,n)+c(1,1);
% c(n-1,2)=c(n-1,2)+c(n-1,n+1);
% c=c(:,2:n);
% px(2:n)=c\X(1:n-1)';
% px(1)=px(n);
% px(n+1)=px(2);
% px(n+2)=px(3);
% py(2:n)=c\Y(1:n-1)';
% py(1)=py(n);
% py(n+1)=py(2);
% py(n+2)=py(3);
% pz(2:n)=c\Z(1:n-1)';
% pz(1)=pz(n);
% pz(n+1)=pz(2);
% pz(n+2)=pz(3);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz] = curv3_spline_comb_plot(spline,np,varargin)
%Disegna il comb di una curva 3D spline
%spline --> struttura formata di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np  --> numero di punti di valutazione per tratto
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% n=spline.deg+1;
%Algoritmo1
%bas_bspl = gc_bpsspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%z=bas_bspl*qz;
%Algoritmo2
%vettore binormale alla curva in ogni punto e calcolo valore curvatura
%vettore normale alla curva in ogni punto
% for i=1:np
%     plot3([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],[z(i),z(i)+tz(i)],'g-')
% end
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function t = curv3_spline_cps_der(Q,t,tt,Qp,g)
%Calcola la lista dei control point della curva spline cubica
%di interpolazione con derivate agli estremi da una lista di punti 3D
%Q      --> matrice dei punti (npuntix3)
%t      --> partizione nodale della curva
%tt     --> parametrizzazione della curva
%Qp     --> matrice delle derivate agli estremi
%cp     <-- lista dei control point (ncpsx3)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function t = curv3_spline_cps_nak(Q,t,tt)
%Calcola la lista dei control point della curva spline cubica
%di interpolazione Not a Knot da una lista di punti 3D
%Q      --> matrice dei punti (npuntix3)
%t      --> partizione nodale della curva
%tt     --> parametrizzazione della curva
%cp     <-- matrice dei control point (ncpsx3)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function t = curv3_spline_cps_nat(Q,t,tt)
%Calcola la lista dei control point della curva spline cubica
%di interpolazione naturale da una lista di punti 3D
%Q      --> matrice dei punti (npuntix3)
%t      --> partizione nodale della curva
%tt     --> parametrizzazione della curva
%cp     <-- matrice dei control point (ncpsx3)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function t = curv3_spline_cps_per(Q,t)
%Calcola la lista dei control point della curva spline cubica
%di interpolazione periodica da una lista di punti 3D
%Q      --> matrice dei punti (npuntix3)
%t      --> partizione nodale della curva
%cp     <-- matrice dei control point (ncpsx3)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function kur = curv3_spline_kur_plot(spline,np,varargin)
%Disegna la funzione curvatura di una curva 3D di Bezier
%spline --> struttura formata di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori di curvatura
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%kur <-- valori della funzione curvatura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function val = curv3_spline_length(spline)
%Calcola il valore della lunghezza di una curva Spline 3D
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%val <-- valore della lunghezza della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function spline=curv3_spline_load(filename)
%Legge una curva 3D spline da file
%filename --> nome del file di estensione .db
%spline <-- struttura formata di una curva spline:
%          spline.deg <-- grado della curva
%          spline.cp  <-- lista dei punti di controllo (ncp)x3 
%          spline.knot  <-- vettore dei nodi (ncp+g+1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado 
%s',1);
%5d',1);   %num. control point
%s',1);
%5d',1);    %num. nodi
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv3_spline_plot(spline,np,varargin)
%Disegna una curva 3D spline
%spline --> struttura formata di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti da plottare per ciascun tratto
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px <-- punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspline = gc_bspl(spline.deg,spline.knot,mesh);
%x=bas_bspline*qx;
%y=bas_bspline*qy;
%z=bas_bspline*qz;
%Algoritmo2
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv3_spline_save(filename, spline)
%Scrive una curva 3D spline su file
%filename --> nome del file di estensione .db
%spline --> struttura formata di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i\n',spline.deg);
%i\n',ncp);
%i\n',nt);
%e %e %e\n',spline.cp(i,1),spline.cp(i,2),spline.cp(i,3));
%e\n',t(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=curv3_spline_tan_plot(spline,np,varargin)
%Disegna il vettore tangente di una curva 3D spline
%spline --> struttura formata di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np   --> numero di punti in cui valutare e disegnare i vettori tangente
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%Px   <-- vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%Algoritmo2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz] = curv3_spline_tcomb_plot(spline,np,varargin)
%Disegna il torsion comb di una curva 3D spline
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np  --> numero di punti di valutazione per tratto
%        se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npx <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Algoritmo1
%bas_bspl = gc_bpsspl(...);
%x=bas_bspl*qx;
%y=bas_bspl*qy;
%z=bas_bspl*qz;
%Algoritmo2
%vettore binormale alla curva in ogni punto e calcolo valore curvatura
%colore e stile linea fissi a solid e magenta
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function tau =curv3_spline_tor_plot(g,P,a,b,np,varargin)
%Disegna la funzione torsione di una curva 3D spline
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori di torsione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%tau <-- valori della funzione torsione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel =curv3_spline_vel_plot(spline,np,varargin)
%Disegna la funzione velocita' di una curva 3D di Bezier
%spline --> struttura formata di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%np --> numero di punti per tratto in cui valutare e disegnare i valori velocita'
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%vel <-- valori della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel =curv3_spline_vel_val(spline,x)
%Calcola il valore della funzione velocita' di una curva 3D di Bezier
%spline --> struttura formata di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo (ncp)x3 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%x --> punto/i in cui valutare
%vel <-- valore/i della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xp,yp,zp]=curv3_tan_plot(cp3name,a,b,np,varargin)
%Disegna i vettori tangente di una curva 3D
%cp3name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%xp,yp,zp <-- coordinate dei vettori tangenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for i=1:abs(np)
%    td(i)=norm([xp(i),yp(i),zp(i)],2);
%    tx(i)=xp(i)/td(i);
%    ty(i)=yp(i)/td(i);
%    tz(i)=zp(i)/td(i);
%end
%    plot3([x(i),x(i)+tx(i)],[y(i),y(i)+ty(i)],[z(i),z(i)+tz(i)],ls)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [npx,npy,npz] = curv3_tcomb_plot(ct3name,a,b,np,varargin)
%Disegna comb della torsione di una curva 3D
%ct3name --> nome del file con l'espressione parametrica
%            della curva fino alla derivata terza
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%npx,npy,npz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for i=1:abs(np)
%    td(i)=norm([xp(i),yp(i),zp(i)],2);
%    tx(i)=xp(i)/td(i);
%    ty(i)=yp(i)/td(i);
%    tz(i)=zp(i)/td(i);
%end
%vettore binormale alla curva in ogni punto e calcolo valore torsione
%colore e stile linea fissi a solid e ciano
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function tau = curv3_tor_plot(ct3name,a,b,np,varargin)
%Disegna la funzione torsione di una curva 3D
%ct3name --> nome del file con l'espressione parametrica
%            della curva fino alla derivata terza
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%tau <-- valori della funzione torsione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=curv3_trans_plot(curvname,a,b,np,M,varargin)
%Disegna una curva 3D dopo aver applicato la trasformazione M 
%curvname --> nome del file con l'espressione parametrica della curva
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%M  --> matrice di trasformazione 4x4
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%x,y,z <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv3_vel_plot(cp3name,a,b,np,varargin)
%Disegna la funzione velocita' di una curva 3D
%cp3name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%a,b --> intervallo di definizione
%np --> numero di punti di valutazione
%       se negativo si valuta, ma non si disegna
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%vel <-- valori della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chiamata di disegno per funzione scalare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vel = curv3_vel_val(cp3name,x)
%calcola il valore della funzione velocita' di una curva 3D
%cp3name --> nome del file con l'espressione parametrica della curva
%            fino alla derivata prima
%x --> punto/i in cui valutare
%vel <-- valore/i della funzione velocita'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [spline_sx,spline_dx]=deboor_subdiv(spline,x)
%Suddivide una curva nD spline definita dai punti di controllo
%spline.cp e dai nodi spline.knot nel punto x mediante l'algoritmo di de Boor
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo 
%          spline.knot  --> vettore dei nodi (ncp+g+1)
%x  --> punto in cui suddividere
%spline_sx <-- struttura dela spline sinistra
%          spline_sx.deg <-- grado della curva
%          spline_sx.cp  <-- lista dei punti di controllo
%          spline_sx.knot  <-- vettore dei nodi (ncp+g+1)
%spline_dx <-- struttura dela spline destra
%          spline_dx.deg <-- grado della curva
%          spline_dx.cp  <-- lista dei punti di controllo
%          spline_dx.knot  <-- vettore dei nodi (ncp+g+1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%determina se il punto di suddivisione 
%e' un nodo e di che molteplicita'
%definiamo la variabile lmlk
%Costruisce le due partizioni nodali risultanti per
%Algoritmo di de Boor per suddividere in due curve spline    
%Imposto nel campo deg il grado delle nuove spline create

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=deboor_val(spline,x)
%Calcola il valore di una curva nD spline nella base B-spline
%definita dai punti di controllo spline.cp nei punti x mediante 
%l'algoritmo di de Boor
%spline --> struttura formata da 3 campi:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo
%          spline.knot  --> vettore dei nodi
%x  --> lista dei punti in cui valutare
%Px <-- coordinate dei punti della curva nei punti x
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% n=length(spline.cp(:,1));
% nt=length(t);
% spline.deg=nt-n-1;
% disp('deboor')
%         disp(size(spline.cp))
%         disp(spline.knot);
%         disp(spline.deg);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=deboor_valder(spline,kk,x)
%Calcola il valore e le derivate fino a ordine kk<=spline.deg di una
%curva nD spline nella base B-spline definita dai punti di 
%controllo spline.cp nei punti x mediante l'algoritmo di de Boor
%spline --> struttura di una curva spline:
%          spline.deg --> grado della curva
%          spline.cp  --> lista dei punti di controllo 
%          spline.knot  --> vettore dei nodi
%kk --> ordine di derivazione (kk<=spline.deg)
%x  --> lista dei punti in cui valutare
%Px <-- punti(i,j,k) della curva spline nei punti x(j)
%       i: indice di derivazione i=1 valore, i=2 derivata prima, ecc.
%       j: indice punto di valutazione
%       k: indice della coordinata del punto della curva nD
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Array di lavoro
% P1 <-- punti di controllo della curva spline sinistra
% t1 <-- vettore nodale della curva sinistra
% P2 <-- punti di controllo della curva spline destra
% t2 <-- vettore nodale della curva destra
%ciclo sui punti di valutazione
%determina se il punto di valutazione/suddivisione 
%e' un nodo e di che molteplicita'
%definiamo la variabile lmlk di lavoro
%Costruisce le due partizioni nodali risultanti 
%Algoritmo di de Boor per valutare/suddividere in due curve spline 
%valutazione derivate con opportuna scalatura
%a1 e a2 settate in fase di definizione delle partizioni nodali
%t1 e t2, permettono di scegliere quella delle due spline piu'
%stabile, ossia quella tra le due per cui l'ultimo intervallo
%nodale di t1 ed il primo di t2 sia piu' grande.
%fprintf('x=%f t2\n',x(k));
%fprintf('%f ',t2);
%fprintf('\n');
%fprintf('x=%f t1\n',x(k));
%fprintf('%f ',t1);
%fprintf('\n');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [bez_sx,bez_dx]=decast_subdiv(bezier,x)
%Suddivide una curva nD di Bezier definita in bezier.ab 
%di punti di controllo bezier.cp nel punto x in bezier.ab
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo
%          bezier.ab  --> intervallo di definizione
%x   --> punto in [a,b] in cui suddividere
%bez_sx <-- struttura della Bezier sinistra risultante:
%          bez_sx.deg --> grado della curva
%          bez_sx.cp  --> lista dei punti di controllo
%          bez_sx.ab  --> intervallo di definizione [a x]
%bez_dx <-- struttura della Bezier sinistra risultante:
%          bez_dx.deg --> grado della curva
%          bez_dx.cp  --> lista dei punti di controllo
%          bez_dx.ab  --> intervallo di definizione [x b]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%imposto i campi mancanti delle curve sinistra e destra
%    c(1)  c(2)  c(3) ...               c(n)
%    c2(1) c2(2) c2(3) ...              c2(n) --> c1(1):=c2(1)
%j=1 c2(1) c2(2)                c2(n-1)       --> c1(2):=c2(1)
%j=2 c2(1) c2(2)        c2(n-2)               --> c1(3):=c2(1)
%...
%j=g c2(1)                                    --> c1(g+1):=c2(1)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=decast_val(bezier,t)
%Calcola il valore di una curva nD nella base di Bernstein in [0,1]
%definita dai punti di controllo bezier.cp nei punti t mediante l'algoritmo
%di de Casteljau
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo
%          bezier.ab  --> intervallo di definizione
%t  --> lista dei punti in cui valutare
%Px <-- punti della curva nei punti t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%cambio di variabile [a,b]-->[0,1]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=decast_valder(bezier,k,t)
%Calcola il valore e le derivate fino a ordine k<=bezier.deg
%di una curva nD di Bezier in bezier.ab definita dai punti di controllo
%bezier.cp nei punti t mediante l'algoritmo di de Casteljau
%bezier --> struttura di una curva di Bezier:
%          bezier.deg --> grado della curva
%          bezier.cp  --> lista dei punti di controllo (g+1)x2
%          bezier.ab  --> intervallo di definizione
%k   --> ordine di derivazione; 0 valore, 1 derivata prima, ecc.
%t   --> lista dei punti in cui valutare
%Px  <-- valori e derivate della curva nei parametri t;
%        Px ha dimensione (k+1) x m x nD, dove m sono i parametri
%        in t ed nD e' la dimensione della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%cambio di variabile [a,b]-->[0,1]
%algoritmo di de Casteljau
%nei vettori V e W ci sono i punti di controllo delle curve nella
%base di Bernstein in [0,tt(ii)] e [t(ii),1], allora
%p(t(ii)) =V(g+1)=W(1)
%p'(t(ii))=grado*(V(g+1)-V(g))/(d1*(b-a))=grado*(W(2)-W(1))/(d2*(b-a))
%ecc.
%valutazione derivate con opportuna scalatura
%d2 e d1 sono moltiplicati ad ogni passo per bma
%in quanto si deve tener conto che abbiamo inizialmente
%operato un cambio di variabile da [a,b]-->[0,1]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function bs=gcw_bspl(g,t,w,x)
%Valuta le funzioni base rational B-spline (non nulle) in x;
%se x e' un vettore torna una matrice
%g  --> grado delle rational B-spline
%t  --> vettore dei knot
%w  --> lista dei pesi
%x  --> lista dei punti in cui valutare
%bs <-- matrice dei valori delle funzioni rational B-spline nei punti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [bsuv,X,Y]=gcw_bspl_2v(gu,gv,u,v,W,x,y)
%Valuta le funzioni rational B-spline in un punto (x,y); se x ed y
%sono vettori torna la matrice bsuv 4D (dove bsuv(l,k,:,:) si riferisce
%al punto griglia di indici (l,k), mentre bsuv(:,:,i,j) si riferisce alla
%RB-spline di indici (i,j) e contiene i valori delle funzioni base 
%calcolate nei punti;
%gu --> grado in u della rational spline
%gv --> grado in v della rational spline
%u  --> vettore dei knot in u
%v  --> vettore dei knot in v
%W  --> matrice dei pesi
%x  --> lista dei punti di valutazione in x
%y  --> lista dei punti di valutazione in y
%bsuv <-- matrice 4D delle funzioni rational B-spline sulla griglia di punti
%         bsuv(:,:,i,j) rappresenta i valori della rational B-spline (i,j) su
%         tutti i punti della griglia di valutazione
%X  <-- matrici delle ascisse
%Y  <-- matrice delle ordinate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Valutazione RB-spline bivariate

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [bs,bs1]=gc_bpspl(g,t,x)
%Valuta le funzioni base B-spline (non nulle) e le loro derivate
%prime in x; se x e' un vettore torna una matrice
%g   --> grado delle B-spline
%t   --> vettore dei knot
%x   --> lista dei punti in cui valutare
%bs  <-- matrice dei valori delle funzioni B-spline nei punti
%bs1 <-- matrice delle derivate prime delle funzioni B-spline nei punti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [bs,bs1,bs2]=gc_bpsspl(g,t,x)
%Valuta le funzioni base B-spline (non nulle) e le loro derivate
%prime e seconde in x; se x e' un vettore torna una matrice
%g   --> grado delle B-spline
%t   --> vettore dei knot
%x   --> lista dei punti in cui valutare
%bs  <-- matrice dei valori delle funzioni B-spline nei punti
%bs1 <-- matrice delle derivate prime delle funzioni B-spline nei punti
%bs2 <-- matrice delle derivate seconde delle funzioni B-spline nei punti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% calcolo dell B-spline di grado g-1
%applica passo per B-spline di grado g-1 e
%formula ricorrente derivata prima B-spline di grado g-1
%applica passo per B-spline di grado g e
%formula ricorrente derivata prima B-spline di grado g
%formula ricorrente derivata seconda B-spline di grado g

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function bs=gc_bspl(g,t,x)
%Valuta le funzioni base B-spline (non nulle) in x;
%se x e' un vettore torna una matrice
%g  --> grado delle B-spline
%t  --> vettore dei knot
%x  --> lista dei punti in cui valutare
%bs <-- matrice dei valori delle funzioni B-spline nei punti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [bs]=gc_bspl_valder(g,t,x,od)
%Valuta le funzioni base B-spline (non nulle) e le loro derivate
%fino a ordine od<=g, in x.
%g   --> grado delle B-spline
%t   --> vettore dei knot
%x   --> lista dei punti in cui valutare
%od  --> ordine di derivazione; 0 valore, 1 valore e derivata, ecc.
%bs  <-- matrice a tre dimensioni dei valori e derivate delle funzioni 
%        B-spline nei punti; il primo indice e' l'ordine di derivazione,
%        il secondo e' l'indice del punto, il terzo e' l'indice della
%        funzione base B-spline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%ciclo sui punti di valutazione
%schema triangolare:
%ciclo sul grado
%ciclo sulle funzioni base di grado i; quelle di indici da l a k-1
%calcolo delle funzioni B-spline derivate nei punti
%          disp([i,j,kk])
%calcolo ultima funzione base di grado i; quelle di indice k
%calcolo dell'ultima funzioni B-spline derivate nei punti; quella di
%indice k

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function l=gc_findinppab(ppab,x)
%Determina l'indice dell'intervalo nodale contenente il punto
%assegnato; se x e' un vettore di punti l sara' un vettore di indici.
%ppab --> vettore dei knot (estremi inclusi)
%x    --> lista dei punti in cui valutare
%l    <-- vettore di indici
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function l=gc_findint(g,t,x)
%Determina l'indice dell'intervalo nodale contenente il punto
%assegnato; se x e' un vettore di punti l sara' un vettore di indici.
%g --> grado della spline
%t --> vettore dei knot
%x --> lista dei punti in cui valutare
%l <-- vettore di indici
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [t_mult,t_single,nt_s]=gc_knot_mult(g,t)
%Analiza la partizione nodale e restituisce informazioni
%sui nodi multipli e singoli
%g --> grado della spline/nurbs
%t --> vettore dei knot
%t_mult <-- molteplicita' di ogni nodo distinto
%t_single <-- lista dei nodi distinti
%nt_s <-- numero di knot distinti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function md = gc_max_dist(pin, p1, pmed, p2, pfin)
%Determina la massima distanza dei punti p1, pmed e p2 dalla
%retta passante per pin e pfin
%pin, pfin --> primo e ultimo punto di un tratto di curva 2D
%p1, pmed, p2 --> punti che si vogliono testare per distanza dalla retta
%md <-- massima distanza calcolata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [nm,mesh]=gc_mesh(g,t,n)
%Viene generate una mesh opportuna dell'intervallo di definizione 
%rispettando i knot e le loro molteplicita'
%g --> grado della spline/nurbs
%t --> vettore dei knot
%n --> numero di punti della mesh per intervallo nodale
%nm    <-- numero punti mesh generati
%mesh  <-- mesh generata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%il nodo viene considerato una sola volta
%   j=nm;
%il nodo viene considerato due volte

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [cpxd,cpyd]=gc_pol_de2d(g,cpx,cpy)
%Degree elevation di una curva 2D di Bezier restituendo i nuovi 
%punti di controllo; il grado del nuovo polinomio sara' g+1
%g         --> grado del polinomio
%cpx,cpy   --> coordinate dei punti di controllo
%cpxd,cpyd <-- coordinate dei nuovi punti di controllo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function R=get_mat2_rot(theta)
%Definisce la matrice 3x3 di rotazione 2D in base all'angolo
%theta in input
%theta --> angolo in radianti (scalare) 
%R     <-- matrice di rotazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function R=get_mat3_rotx(theta)
%Definisce la matrice 4x4 di rotazione 3D intorno all'asse x
%in base all'angolo theta in input
%theta --> angolo in radianti (scalare) 
%R     <-- matrice di rotazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function R=get_mat3_roty(theta)
%Definisce la matrice 4x4 di rotazione 3D intorno all'asse y
%in base all'angolo theta in input
%theta --> angolo in radianti (scalare) 
%R     <-- matrice di rotazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function R=get_mat3_rotz(theta)
%Definisce la matrice 4x4 di rotazione 3D intorno all'asse z
%in base all'angolo theta in input
%theta --> angolo in radianti (scalare) 
%R     <-- matrice di rotazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function S=get_mat_scale(s)
%Definisce la matrice di 3x3 o 4x4 di scala in base al
%vettore d (2D o 3D) in input
%s --> vettore di scala 2D o 3D
%S <-- matrice di scala
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function T=get_mat_trasl(d)
%Definisce la matrice di 3x3 o 4x4 di traslazione in base al
%vettore d (2D o 3D) in input
%d --> vettore traslazione 2D o 3D
%T <-- matrice di traslazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function c=greville(g,t)
%Calcola per uno spazio spline dato mediante grado e partizione
%nodale, le ascisse di Greville
%g  --> grado della spline
%t  --> partizione nodale della spline
%c  <-- lista dei punti di Greville
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     disp([t(i+1),t(i+2),t(i+3)]);

%     fprintf('%s\n',ll);

%INTERX Intersection of curves
%   P = INTERX(L1,L2) returns the intersection points of two curves L1 
%   and L2. The curves L1,L2 can be either closed or open and are described
%   by two-row-matrices, where each row contains its x- and y- coordinates.
%   The intersection of groups of curves (e.g. contour lines, multiply 
%   connected regions etc) can also be computed by separating them with a
%   column of NaNs as for example
%
%         L  = [x11 x12 x13 ... NaN x21 x22 x23 ...;
%               y11 y12 y13 ... NaN y21 y22 y23 ...]
%
%   P has the same structure as L1 and L2, and its rows correspond to the
%   x- and y- coordinates of the intersection points of L1 and L2. If no
%   intersections are found, the returned P is empty.
%
%   P = INTERX(L1) returns the self-intersection points of L1. To keep
%   the code simple, the points at which the curve is tangent to itself are
%   not included. P = INTERX(L1,L1) returns all the points of the curve 
%   together with any self-intersection points.
%   
%   Example:
%       t = linspace(0,2*pi);
%       r1 = sin(4*t)+2;  x1 = r1.*cos(t); y1 = r1.*sin(t);
%       r2 = sin(8*t)+2;  x2 = r2.*cos(t); y2 = r2.*sin(t);
%       P = InterX([x1;y1],[x2;y2]);
%       plot(x1,y1,x2,y2,P(1,:),P(2,:),'ro')
%   Author : NS
%   Version: 3.0, 21 Sept. 2010
%   Two words about the algorithm: Most of the code is self-explanatory.
%   The only trick lies in the calculation of C1 and C2. To be brief, this
%   is essentially the two-dimensional analog of the condition that needs
%   to be satisfied by a function F(x) that has a zero in the interval
%   [a,b], namely
%           F(a)*F(b) <= 0
%   C1 and C2 exactly do this for each segment of curves 1 and 2
%   respectively. If this condition is satisfied simultaneously for two
%   segments then we know that they will cross at some point. 
%   Each factor of the 'C' arrays is essentially a matrix containing 
%   the numerators of the signed distances between points of one curve
%   and line segments of the other.
%...Argument checks and assignment of L2
%...Avoid the inclusion of common points
%...Preliminary stuff
%...Determine 'signed distances'   
%...Obtain the segments where an intersection is expected
%...Transpose and prepare for output
%...Avoid divisions by 0
%...Solve system of eqs to get the common points

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function roots = lane_riesenfeld(fun,TOL)
%Determina gli zeri di una funzione polinomiale data nella base di 
%Bernstein in un intervallo (quello di definizione della base);
%utilizza il metodo denominato in letteratura 'Lane-Riesenfeld'
%fun   --> struttura funzione polinomiale nella base di Bernstein 
%TOL   --> tolleranza
%roots <-- vettore delle radici trovate
%Nota. al momento questa function viene richiamata dalle function
%      della libreria curv2_bezier_offset.m e curv2_ppbezier_offset.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%isolamento di zeri; se uno zero e' multiplo non si riesce a determinare
%un intervallo in cui ci sia una sola variazione di segno, in tal caso la
%routine determina lei lo zero con una convergenza lineare.
%zero variazioni di segno
%una variazione di segno
%Aggiunta al programma originale per
%trovare gli zeri in casi eccezionali 
%if
%if
%while
%Per ogni intervallo in cui c'e' una variazione di segno,
%viene determinato uno zero.
%       Top_Bezier(p);
%|C_1| < Epsilon => zero=p.a
%|C_n+1| < Epsilon => zero=p.b
%vengono trovati i 2 coeff. che hanno una variazione di segno
% if flag
% while flag
% while
%funzione di stampa per fare debug
% for i=1:Bezier_idx
%    fprintf('indice %d \n',i);
%    disp(buf(i));
%    disp(buf(i).cp);
% end
%variazioni in segno dei coeff. di Bezier; non e' variazione in senso
%debole, ma nenche in senso forte. E' opportuna per recuperare
%coeff. che sono nulli
% fprintf('Variazioni di segno = %d\n',num);
%predispone lo stack a ricevere un nuovo elemento
% Inizializzazione dell'indice dello stack
% Controllo per vedere se lo stack e' vuoto
% Viene presa la funzione piu' in alto sullo stack
% Si decrementa l'indice dello stack 
% Si inserisce un elemento nello stack
% buf(Bezier_idx)=q; %pare che così non vada bene
% procediamo a copiare campo per campo
% si copia e trasforma il vettore cp in un vettore riga
%suddivide in due

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,varargout] = line_plot(p,v,a,b,varargin)
%Disegna una linea 2D o 3D nella forma p+tv con t in [a,b]
%p  --> punto 2D o 3D
%v  --> vettore 2D o 3D
%a,b --> intervallo parametrico
%varargin --> argomenti opzionali di disegno da assegnare nel seguente 
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%[x,y,varargout] <-- coordinate dei punti plottati. Si invochera' [x,y] 
%                    per disegno 2D oppure [x,y,z] per disegno 3D
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%default per i parametri 
%sovrascrivo in optargs gli opzionali specificati in varargin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [q,u]=line_trans(p,v,M)
%Trasforma una linea 2D o 3D nella forma p+tv con t in [a,b]
%applicando la matrice M
%p  --> punto 2D o 3D
%v  --> vettore 2D o 3D
%M   --> matrice di trasformazione
%ATTENZIONE: se i punti sono 2D la matrice deve essere 3x3,
%            se i punti 3D la matrice deve essere 4x4.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,varargout] = line_trans_plot(p,v,a,b,M,varargin)
%Disegna una linea 2D o 3D nella forma p+tv con t in [a,b] dopo
%averla trasformata con la matrice M
%p  --> punto 2D o 3D
%v  --> vettore 2D o 3D
%a,b --> intervallo parametrico
%M   --> matrice di trasformazione
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%ATTENZIONE: se i punti sono 2D la matrice deve essere 3x3,
%            se i punti 3D la matrice deve essere 4x4.
%[x,y,varargout] <-- coordinate dei punti plottati. Si invochera' [x,y] per
%                    disegno 2D oppure [x,y,z] per disegno 3D
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%default per i parametri 
%sovrascrivo in optargs gli opzionali specificati in varargin
%nv=length(v);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=mdppdecast_val(ppbez,t)
%Calcola il valore di una curva nD di Bezier a tratti multi-degree
%definita dai punti di controllo P nei punti t 
%mdppbez --> struttura di una Bezier a tratti multi-degree:
%          mdppbez.deg --> lista dei gradi dei tratti della curva
%          mdppbez.cp  --> lista dei punti di controllo ncp x 2
%          mdppbez.ab  --> lista degli estremi dei tratti
%t  --> lista dei punti in cui valutare
%Px <-- punti della curva valutata in corrispondenza dei punti t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%indici relativi agli intervalli dei punti in cui valutare
%indici dei CP per intervallo nodale

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function mesh_curv2_plot_edit(x,y,varargin)
%Disegna una mesh di punti 2D
%x,y --> coordinate della mesh 2D
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Test sul numero di opt inseriti
%Default per i parametri opzionali
%Sovrascrivo in optargs gli opzionali specificati in varargin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function mesh_curv3_plot(x,y,z,varargin)
%Disegna una mesh di punti 3D
%x,y,z --> coordinate della mesh 3D
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%default per i parametri 
%sovrascrivo in optargs gli opzionali specificati in varargin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function mesh_surf_plot( x, y, z, col, type, varargin )
%Disegna una mesh di punti 3D
%x,y,z --> coordinate della mesh 3D (x,y,z sono matrici nxm) 
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLighting: 'flat', 'gouraud', 'none', 'phong' 
%Esempio di chiamata:
%mesh_surf_plot( x, y, z, 'r', 3, 'flat', 'k', 'none' );
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% case per la personalizzazione dell'aspetto della surf
%check sul numero di argomenti opzionali
%se non sono specificati valori, set default
%set light

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=nurbs_val(nurbs,x)
%Calcola il valore nei punti x di una curva nD nurbs nella base B-spline
%definita dai punti di controllo nurbs.cp mediante
%l'algoritmo di de Boor
%nurbs --> struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo
%          nurbs.knot  --> vettore dei nodi
%          nurbs.w --> lista dei pesi (weight)
%x  --> lista dei punti in cui valutare
%Px <-- coordinate dei punti della curva nurbs nei punti x
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=nurbs_valder(nurbs,kk,x)
%Calcola il valore nei punti x e le derivate fino a ordine kk<=g di una
%curva nD spline nella base B-spline definita dai punti di 
%controllo P mediante l'algoritmo di de Boor
%nurbs --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo 
%          nurbs.knot  --> vettore dei nodi
%kk --> ordine di derivazione (kk<=g)
%x  --> lista dei punti in cui valutare
%Px <-- punti della curva nurbs nei punti x
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%calcolo del valore
%calcolo valore derivata prima
%calcolo valore derivata seconda
%calcolo valore derivata terza

% Offset a curve by a given distance
% Inputs:
%       x, y: input x and y coordinates
%       offset: offset amount in arbitrary units or in points if haxes
%           is provided
%       haxes: handle to parent axis if offset is determined in points
%       intersectremove: remove self-intersecting portions (default is
%           true)
%
% J. Duchateau, - IHU LIRYC, Bordeaux, France - 2015. 
%
% You are free to distribute/modify as you please.
% First check for colinear points and remove them
% Now offset...
% 1) Get unit vector size in points
% 2) Convert vector directions in points
% 3) Rotate by 90
% 4) Offset by input offset value
% 5) Convert back to axes units
% Now that we have all our offsets, compute intersections between lines
% 1) Create new segment list
% 2) Join neighboring segments
% Find intersection with next
% Remove the next segment which is colinear
% Add the intersection to the point list
% 3) Remove self-intersections
% Find candidates for self intersection
% Fast scan of candidates
% Both on right side
% Parallel segments
% First step: data units to relative inside axis
% Second step: go up to figure
%Multiply to go to parent
% Convert units to points and add up
% Third step: Convert from relative to figure to paper point
% Convert to point from input unit

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function ido=open_figure(id)
%Apertura di una finestra grafica e setting di alcuni parametri
%id --> identificatore della finestra (opzionale)
%id <-- identificatore della finestra (opzionale)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function t = partition_der(x)
%Calcola la partizione nodale, per il metodo di interpolazione
%con spline cubiche e condizione di derivate agli estremi, 
%da una lista di punti  
%x      --> vettore da cui ricavare la partizione nodale
%t      <-- partizione nodale corrisponente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function t = partition_nak(x)
%Calcola la partizione nodale, per il metodo di interpolazione
%con spline cubiche e condizione not-a-knot, da una lista di punti
%x      --> vettore da cui ricavare la partizione nodale
%t      <-- partizione nodale corrisponente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function t = partition_nat(x)
%Calcola la partizione nodale, per il metodo di interpolazione
%con spline cubiche e condizione naturale, da una lista di punti
%x      --> vettore da cui ricavare la partizione nodale
%t      <-- partizione nodale corrisponente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function t = partition_per(x)
%Calcola la partizione nodale, per il metodo di interpolazione
%con spline cubiche e condizione periodica, da una lista di punti
%x      --> vettore da cui ricavare la partizione nodale
%t      <-- partizione nodale corrisponente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function curv=periodic(curv,order)
%
%curv  --> struttura di una curva spline o nurbs nD:
%          curv.deg --> grado della curva
%          curv.cp  --> lista dei punti di controllo (ncp)xnD 
%          curv.knot  --> vettore dei nodi (ncp+g+1)
%          curv.w   --> coefficienti pesi
%ordine --> ordine di continuita' richiesto nel punto di chiusura
%curv  <-- curva spline e nurbs nD modificata per essere periodica
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%grado
%numero di cp della curva
%estremo sinistro intervallo di def
%numero totale nodi partizione estesa
%numero nodi interni partizione nodale
%estremo destro intervallo di def
%replica degli intervalli e quindi definizione
%dei nodi aggiuntivi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z] = plane_plot(n,O,a,b,c,d,varargin)
%Disegna un piano 3D come O+uv1+vv2 con u in [a,b], v in [c,d]
%e v1 v2 vettori giacitura determinati conoscendo la normale n
%n   --> vettore normale 3D
%O   --> punto 3D
%a,b --> intervallo parametrico in u
%c,d --> intervallo parametrico in v
%varargin --> specificare le proprieta' del disegno, in ordine:
%             FaceColor('none','flat','interp',colorname), EdgeColor('none','flat','interp',colorname), 
%             FaceLightning ('flat', 'gouraud', 'none','phong') 
%[x,y,z] <-- coordinate dei punti plottati.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di argomenti opzionali
%se non sono specificati valori, set default
%plot3(x,y,z,'k');
%patch(x,y,z,'FaceColor',fc,'EdgeColor',ec,'Facelighting',fl);
%plot3(O(1),O(2),O(3),'bo','MarkerSize',6,'MarkerFaceColor','b');
%vect3_plot(O,n,'b');
%%vect3_plot(O,vv1,'g');
%%vect3_plot(O,vv2,'g');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z] = plane_trans_plot(n,O,a,b,c,d,M,varargin)
%Trasforma un piano 3D come O+uv1+vv2 con u in [a,b], v in [c,d]
%e v1 v2 vettori giacitura determinati conoscendo la normale n
%applicandogli la matrice M
%n  --> vettore normale 3D
%O  --> punto 3D
%a,b --> intervallo parametrico in u
%c,d --> intervallo parametrico in v
%M   --> matrice di traformazione 4x4
%varargin --> specificare le proprieta' del disegno, in ordine:
%             FaceColor('none','flat','interp',colorname), EdgeColor('none','flat','interp',colorname), 
%             FaceLightning ('flat', 'gouraud', 'none')
%[x,y,z] <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di argomenti opzionali
%se non sono specificati valori, set default
%plot3(x,y,z,col);
%patch(x,y,z,'FaceColor',fc,'EdgeColor',ec,'Facelighting',fl);
%plot3(O(1),O(2),O(3),'bo','MarkerSize',6,'MarkerFaceColor','b');
%vect3_plot(O,n,'b');
%%vect3_plot(O,vv1,'g');
%%vect3_plot(O,vv2,'g');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function plot_properties(varargin)
%Setta i parametri opzionali del disegno
%varagin puo' contenere da 0 a tutti e 5 tra questi parametri nel
%seguente ordine:
%ls  --> line specification
%lw  --> line width
%mfc --> marker face color
%mec --> marker edge color
%ms  --> marker size
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% valori di default
% put these defaults into the valuesToUse cell array, 
% and overwrite the ones specified in varargin.
% se specificati, inserisco i valori definiti in varargin al posto di quelli di default
% Place optional args in memorable variable names

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function point_plot(p,varargin)
%Disegna punti, liste di punti o griglie di punti 2D e 3D
%p  --> punto/i 2D o 3D (nx2 o nx3)
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%default per i parametri opzionali
%sovrascrivo in optargs gli opzionali specificati in varargin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function q=point_trans(p,M)
%Calcola liste di punti o griglie di punti 2D e 3D dopo
%averli trasformati con la matrice M
%p  --> punto/i 2D o 3D
%M  --> matrice di trasformazione
%q  <-- punto/i 2D o 3D trasformati
%ATTENZIONE: se i punti sono 2D la matrice deve essere 3x3,
%            se i punti 3D la matrice deve essere 4x4.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function q=point_trans_plot(p,M,varargin)
%Disegna punti, liste di punti o griglie di punti 2D e 3D dopo
%averli trasformati con la matrice M
%p  --> punto/i 2D o 3D
%M  --> matrice di trasformazione
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize
%q  <-- punto/i 2D o 3D trasformati
%ATTENZIONE: se i punti sono 2D la matrice deve essere 3x3,
%            se i punti 3D la matrice deve essere 4x4.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%default per i parametri opzionali
%sovrascrivo in optargs gli opzionali specificati in varargin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [ppbezier_sx,ppbezier_dx]=ppbezier_subdiv(ppP,x)
%Suddivide una curva nD di bezier a tratti (ppP)
%definita dai punti di controllo ppP.cp nei punti x mediante 
%l'algoritmo di de Boor
%ppP --> struttura formata da 3 campi:
%          ppbezier.deg --> grado della curva
%          ppbezier.cp  --> lista dei punti di controllo
%          ppbezier.ab  --> partizione nodale
%x  --> punto in cui suddividere
%ppbezier_sx <-- struttura formata da 3 campi:
%          ppbezier_sx.deg --> grado della curva
%          ppbezier_sx.cp  --> lista dei punti di controllo
%          ppbezier_sx.ab  --> partizione nodale
%ppbezier_dx <-- struttura formata da 3 campi:
%          ppbezier_dx.deg --> grado della curva
%          ppbezier_dx.cp  --> lista dei punti di controllo
%          ppbezier_dx.ab  --> partizione nodale
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%converte la curva ppP in una struttura spline a nodi multipli
%e utilizza la deboor_subdiv per la suddivisione
%conversione della la ppP bezier a tratti in una struttura spline

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=ppbezier_val(ppP,x)
%Calcola il valore di una curva nD di bezier a tratti (ppP)
%definita dai punti di controllo ppP.cp nei punti x mediante 
%l'algoritmo di de Boor
%ppP --> struttura formata da 3 campi:
%          ppbezier.deg --> grado della curva
%          ppbezier.cp  --> lista dei punti di controllo
%          ppbezier.ab  --> partizione nodale
%x  --> lista dei punti in cui valutare
%Px <-- coordinate dei punti della curva nei punti x
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%converte la curva ppP in una struttura spline a nodi multipli
%e utilizza la deboor_val per la valutazione
%conversione della la ppP bezier a tratti in una struttura spline

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=ppbezier_valder(ppP,k,t)
%Calcola il valore e le derivate fino a ordine k<=ppP.deg
%di una curva nD di Bezier a tratti in ppP.ab definita dai punti 
%di controllo ppP.cp nei punti t mediante l'algoritmo di de deboor
%ppP --> struttura di una curva di Bezier a tratti:
%          ppP.deg --> grado della curva
%          ppP.cp  --> lista dei punti di controllo
%          ppP.ab  --> partizione nodale
%k   --> ordine di derivazione; 0 valore, 1 derivata prima, ecc.
%t   --> lista dei punti in cui valutare
%Px  <-- valori e derivate della curva nei parametri t;
%        Px ha dimensione (k+1) x m x nD, dove m sono i parametri
%        in t ed nD e' la dimensione della curva
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%converte la curva ppP in una struttura spline a nodi multipli
%e utilizza la deboor_val per la valutazione
%conversione della la ppP bezier a tratti in una struttura spline

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Script per la definizione di una curva di Bezier a tratti 
%in modo interattivo grafico
%eseguire lo script dando il nome da command window
%ATTENZIONE: lo script permette di salvare solo curve di Bezier;
%            il file .db verra' salvato nella cartella corrente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Px=ppdecast_val(ppbez,t)
%Calcola il valore di una curva nD nella base di Bernstein a tratti
%definita dai punti di controllo P nei punti t 
%ppbez --> struttura di una Bezier a tratti:
%          ppbez.deg --> grado della curva
%          ppbez.cp  --> lista dei punti di controllo ncp x 2
%          ppbez.ab  --> estremi dei tratti nc
%t  --> lista dei punti in cui valutare
%Px <-- punti della curva nei punti t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%indici relativi agli intervalli dei punti in cui valutare

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function dy=scalar_derivatives(qx,qy)
%Stima discreta delle derivate a partire da una lista di punti
%qx,qy --> coordinate punti di una funzione univariata
%dy    <-- valore stimato della derivata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xx,yy,zz] = solid_box_plot(a,b,nu,nv,type,varargin)
%Disegna un solido elementare: box
%si tratta di un box definito da due vertici opposti;
%a,b --> punti 3D che definiscono i vertici opposti del box
%nu,nv  --> numero punti griglia di valutazione per ogni faccia
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%xx,yy,zz <-- coordinate dei ppunti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%costruiamo il vettore degli 8 vertici del box
%disegno delle 6 facce
% for i=1:6
%   patch(x(f(i,:)),y(f(i,:)),z(f(i,:)),col);
% end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xx,yy,zz] = solid_box_trans_plot(a,b,nu,nv,M,type,varargin)
%Disegna un solido elementare: box
%si tratta di un box definito da due vertici opposti;
%a,b --> punti 3D che definiscono i vertici opposti del box
%nu,nv  --> numero punti griglia di valutazione per ogni faccia
%M   --> matrice di trasformazione
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%xx,yy,zz <-- coordinate dei ppunti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%costruiamo il vettore degli 8 vertici del box
%disegno delle 6 facce
% for i=1:6
%   patch(x(f(i,:)),y(f(i,:)),z(f(i,:)),col);
% end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z] = solid_cone_plot(A,B,rA,rB,nu,nv,type,varargin)
%Disegna un solido elementare: tronco di cono
%si tratta di un tronco di cono definito dall'asse di estremi A e B
%e dai raggi rA ed rB;
%A,B --> punti 3D che definiscono l'asse del tronco di cono
%rA  --> raggio della base inferiore
%rB  --> raggio della base superiore
%nu,nv  --> numero punti griglia di valutazione per ogni faccia
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%x,y,z <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%rappresentazione grafica di un solido elementare: cone
%si tratta di un cone definito dall'asse di estremi A e B e dai raggi rA ed rB;
%cerchio di centro O, raggio r giacente sul piano
%con normale n per t in [0,2*pi]
%elseif (n(2)~=0)
%    ortn=[0,-n(3),n(2)];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z] = solid_cone_trans_plot(A,B,rA,rB,nu,nv,M,type,varargin)
%Disegna un solido elementare: tronco di cono
%si tratta di un tronco di cono definito dall'asse di estremi A e B
%e dai raggi rA ed rB;
%A,B --> punti 3D che definiscono l'asse del tronco di cono
%rA  --> raggio della base inferiore
%rB  --> raggio della base superiore
%nu,nv  --> numero punti griglia di valutazione per ogni faccia
%M   --> matrice di trasformazione
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%x,y,z <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%rappresentazione grafica di un solido elementare: cone
%si tratta di un cone definito dall'asse di estremi A e B e dai raggi rA ed rB;
%cerchio di centro O, raggio r giacente sul piano
%con normale n per t in [0,2*pi]
%elseif (n(2)~=0)
%    ortn=[0,-n(3),n(2)];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z] = solid_cylinder_plot(A,B,r,nu,nv,type,varargin)
%Disegna un solido elementare: cylinder
%si tratta di un cylinder definito dall'asse di estremi A e B 
%e dal raggio r;
%A,B --> punti 3D che definiscono l'asse del cilindro
%r   --> raggio della base
%nu,nv  --> numero punti griglia di valutazione
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%x,y,z <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%cerchio di centro O, raggio r giacente sul piano
%con normale n per t in [0,2*pi]
%elseif (n(2)~=0)
%    ortn=[0,-n(3),n(2)];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z] = solid_cylinder_trans_plot(A,B,r,nu,nv,M,type,varargin)
%Disegna un solido elementare: cylinder
%si tratta di un cylinder definito dall'asse di estremi A e B 
%e dal raggio r;
%A,B --> punti 3D che definiscono l'asse del cilindro
%r   --> raggio della base
%nu,nv  --> numero punti griglia di valutazione
%M   --> matrice di trasformazione
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%x,y,z <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%cerchio di centro O, raggio r giacente sul piano
%con normale n per t in [0,2*pi]
%elseif (n(2)~=0)
%    ortn=[0,-n(3),n(2)];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function solid_plot(solidname,nu,nv,type,varargin)
%Disegna un solido definito per nome 
%solidname --> Cube, Cylinder, Cone
%nu,nv  --> numero punti griglia di valutazione per ogni faccia
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong' 
%NB: nel caso 'cube' l'argomento type non viene considerato, set type=3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO
%R=[cos(v), -sin(v), 0, 0;
%   sin(v),  cos(v), 0, 0;
%   0,       0,      1, 0;
%   0,       0,      0, 1];
%surf_from_curv_plot('c3_line5',0,1,nu,R,0,2*pi,nv,'r',type);
%R=[cos(v), -sin(v), 0, 0;
%   sin(v),  cos(v), 0, 0;
%   0,       0,      1, 0;
%   0,       0,      0, 1];
%surf_from_curv_plot('c3_line4',0,1,nu,R,0,2*pi,nv,col,type);
%surf_from_curv_plot('c3_circleXY',0.5*pi,2.5*pi,nu,S,0,2,nv,col,type);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function solid_sphere_plot(O,r,nu,nv,type,varargin)
%Disegna un solido elementare: sphere
%si tratta di una sfera di centro O e raggio r;
%O --> punto 3D che definisce il centro della sfera
%r --> raggio della sfera
%nu,nv  --> numero punti griglia di valutazione per ogni faccia
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong' 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%sfera di centro O, raggio r giacente

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function solid_sphere_trans_plot(O,r,nu,nv,M,type,varargin)
%Disegna un solido elementare: sphere
%si tratta di una sfera di centro O e raggio r;
%O --> punto 3D che definisce il centro della sfera
%r --> raggio della sfera
%nu,nv  --> numero punti griglia di valutazione per ogni faccia
%M   --> matrice di trasformazione
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong' 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%sfera di centro O, raggio r giacente

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function solid_trans_plot(solidname,nu,nv,M,type,varargin)
%Disegna un solido definito per nome dopo aver applicato una
%matrice di trasformazione
%solidname --> Cube, Cylinder, Cone
%nu,nv  --> numero punti griglia di valutazione per ogni faccia
%M   --> matrice di trasformazione
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong' 
%NB: nel caso 'cube' l'argomento type non viene considerato, set type=3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO
%R=[cos(v), -sin(v), 0, 0;
%   sin(v),  cos(v), 0, 0;
%   0,       0,      1, 0;
%   0,       0,      0, 1];
%surf_from_curv_trans_plot('c3_line5',0,1,nu,R,0,2*pi,nv,M,'r',type);
%R=[cos(v), -sin(v), 0, 0;
%   sin(v),  cos(v), 0, 0;
%   0,       0,      1, 0;
%   0,       0,      0, 1];
%surf_from_curv_trans_plot('c3_line4',0,1,nu,R,0,2*pi,nv,M,col,type);
%surf_from_curv_trans_plot('c3_circleXY',0.5*pi,2.5*pi,nu,S,0,2,nv,M,col,type);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surfbezier=surf_bezier_load(filename)
%Legge una superficie 3D di Bezier da file
%filename --> nome del file di estensione .db
%surfbezier <-- struttura di una superficie di Bezier:
%      surfbezier.deguv <-- gradi della superficie in u e in v
%      surfbezier.cp <-- griglia dei punti di controllo (degu+1)x(degv+1)x3
%      surfbezier.ab  <-- intervallo di definizione in u
%      surfbezier.cd  <-- intervallo di definizione in v
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado in u
%5d',1);    %grado in v 
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xx,yy,zz] = surf_bezier_plot(surfbezier, nu, nv, type, varargin)
%Disegna una superficie 3D di Bezier
%surfbezier --> struttura di una superficie di Bezier:
%      surfbezier.deguv --> gradi della superficie in u e in v
%      surfbezier.cp --> griglia dei punti di controllo (degu+1)x(degv+1)x3
%      surfbezier.ab  --> intervallo di definizione in u
%      surfbezier.cd  --> intervallo di definizione in v
%nu,nv --> numero dei punti da plottare (nuxnv)
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%xx,yy,zz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%griglia di valutazione
%Algoritmo2: usa de Casteljau
%In alternativa calcola ncpu curve in u ed nv curve in v
%     bez_v.deg= surfbezier.deguv(1);
%     bez_u.deg=surfbezier.deguv(2);
%Algoritmo1: usa base di Bernstein
%bsu=bernst(gu,uu);
%bsv=bernst(gv,vv);
%
%xx=bsu*x*bsv';
%yy=bsu*y*bsv';
%zz=bsu*z*bsv';
%Algoritmo2: usa de Casteljau
%calcola ncpv curve in v ed nu curve in u
% R=zeros(ncpu,3);
% Px=zeros(nu,ncpv,3);
% for j=1:ncpv
%     R=squeeze(surfbezier.cp(:,j,:));
%     bez_v.cp= R;
%     bez_v.ab=[surfbezier.ab(1) surfbezier.ab(2)];
%     bez_v.deg= surfbezier.deguv(2);
%     Q=decast_valder(bez_v,0,uu);
%     for i=1:nu
%         Px(i,j,:)=Q(1,i,:);
%     end
% end
% S=zeros(ncpu,3);
% PPx=zeros(nu,nv,3);
% for i=1:nu
%     S=squeeze(Px(i,:,:));
%     bez_u.cp=S;
%     bez_u.ab=[surfbezier.cd(1) surfbezier.cd(2)];
%     bez_u.deg=surfbezier.deguv(1);
%     T=decast_valder(bez_u,0,vv);  
%     for j=1:nv
%      PPx(i,j,:)=T(1,j,:);
%     end    
% end
%disegna superficie in modalita' wire-frame

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surf_bezier_save(filename, gu, gv, P, a, b, c, d)
%Scrive una superficie 3D di Bezier su file
%filename --> nome del file di estensione .db
%surfbezier --> struttura di una superficie di Bezier:
%      surfbezier.deguv --> gradi della superficie in u e in v
%      surfbezier.cp --> griglia dei punti di controllo (degu+1)x(degv+1)x3
%      surfbezier.ab  --> intervallo di definizione in u
%      surfbezier.cd  --> intervallo di definizione in v
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i        %i\n',surfbezier.deguv(1),surfbezier.deguv(2));
%e %e %e\n',surfbezier.cp(i,j,1),surfbezier.cp(i,j,2),surfbezier.cp(i,j,3));
%e\n',surfbezier.ab(1));
%e\n',surfbezier.ab(2));
%e\n',surfbezier.cd(1));
%e\n',surfbezier.cd(2));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=surf_from_curv_plot(curvname,a,b,nu,R,c,d,nv,type,varargin)
%Disegna una superficie generata da una curva
%curvname --> nome del file con l'espressione parametrica della curva
%a,b --> intervallo di definizione in u
%nu  --> numero di punti di valutazione in u
%R --> matrice di trasformazione simbolica 4x4
%c,d --> intervallo di definizione in v
%nv  --> numero di punti di valutazione in v
%col --> colore di disegno
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong' 
%x,y,z <-- coordinate punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%v=vv(j);
%T=eval(R);
% switch type
% case 1
%    mesh(x,y,z);
% case 2
%    surf(x,y,z);
% case 3
%    surf(x,y,z,'FaceColor',gccol,'EdgeColor','none');
%    view(90,90);
%    camlight left;
%    lighting phong
% end
% %view(45,30);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=surf_from_curv_trans_plot(curvname,a,b,nu,R,c,d,nv,M,type,varargin)
%Disegna una superficie generata da una curva dopo aver applicato una
%matrice di trasformazione
%curvname --> nome del file con l'espressione parametrica della curva
%a,b --> intervallo di definizione in u
%nu  --> numero di punti di valutazione in u
%R --> matrice di trasformazione simbolica 4x4
%c,d --> intervallo di definizione in v
%nv  --> numero di punti di valutazione in v
%M --> matrice di trasformazione 4x4
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%x,y,z <-- coordinate punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%v=vv(j);
%T=eval(R);
% switch type
% case 1
%    mesh(x,y,z);
% case 2
%    surf(x,y,z);
% case 3
%    surf(x,y,z,'FaceColor',gccol,'EdgeColor','none');
%    view(90,90);
%    camlight left;
%    lighting phong
% end
%view(45,30);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surfnurbs=surf_nurbs_extruded(nurbs,vect,dist)
%Genera una superficie 3D nurbs per estrusione di una curva 3D nurbs
%nurbs --> struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%vect  --> vettore 3D
%dist  --> scalare
%surfnurbs <-- struttura di una superficie spline:
%      surfnurbs.deguv <-- grado della superficie in u e in v
%      surfnurbs.cp <-- griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfnurbs.ku  <-- vettore dei knot in u
%      surfnurbs.kv <-- vettore dei knot in v
%      surfnurbs.w <-- griglia dei pesi (ncpu)x(ncpv)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xx,yy,zz] = surf_nurbs_kurHK_plot(surfnurbs, ni, nj, cflag)
%Disegna una superficie 3D nurbs
%surfnurbs --> struttura di una superficie spline:
%      surfnurbs.deguv --> grado della superficie in u e in v
%      surfnurbs.cp --> griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfnurbs.ku  --> vettore dei knot in u
%      surfnurbs.kv  --> vettore dei knot in v
%      surfnurbs.w --> griglia dei pesi (ncpu)x(ncpv)
%ni,nj --> numero di punti da plottare (nixnj) per ogni tratto 
%cflag --> 1.curvatura media
%          2.curvatura Gaussiana
%xx,yy,zz <-- coordinate dei punti plottati
%cc <-- valore curvatura nei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%griglia di valutazione
%Algoritmo1: usa B-spline
%Coefficienti della prima forma fondamentale
%Coefficienti della seconda forma fondamentale
%curvatura Media
%curvatura Gaussiana
%   // Coefficienti della prima forma fondamentale
%   E = du[0]*du[0] + du[1]*du[1] + du[2]*du[2];
%   F = du[0]*dv[0] + du[1]*dv[1] + du[2]*dv[2];
%   G = dv[0]*dv[0] + dv[1]*dv[1] + dv[2]*dv[2];
%   // Coefficienti della seconda forma fondamentale
%   e = d2u[0]*nn[0] + d2u[1]*nn[1] + d2u[2]*nn[2];
%   f = duv[0]*nn[0] + duv[1]*nn[1] + duv[2]*nn[2];
%   g = d2v[0]*nn[0] + d2v[1]*nn[1] + d2v[2]*nn[2];
%   // Curvatura media H
%   // NOTA: e' stato messo un segno "-" davanti, per coerenza con la convenzione delle normali esterne e della scala di colori
%   // usualmente associata alla curvatura (positiva-rossi, negativa-blu)
%   HK[0] = -(e*G-2.0*f*F+g*E)/(2.0*(E*G-F*F));
%   // Curvatura gaussiana K
%   HK[1] = (e*g-f*f)/(E*G-F*F);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surfnurbs=surf_nurbs_load(filename)
%Legge una superficie 3D nurbs da file
%filename --> nome del file di estensione .db
%surfnurbs <-- struttura di una superficie spline:
%      surfnurbs.deguv <-- grado della superficie in u e in v
%      surfnurbs.cp <-- griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfnurbs.ku  <-- vettore dei knot in u
%      surfnurbs.kv  <-- vettore dei knot in v
%      surfnurbs.w <-- griglia dei pesi (ncpu)x(ncpv)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado in u
%5d',1);
%s',1);
%5d',1);   %num. control point in u
%5d',1);
%s',1);
%5d',1);    %num. nodi in u
%5d',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%  x(i,j)=str2num(xs);
%  y(i,j)=str2num(ys);
%  z(i,j)=str2num(zs);
%  w(i,j)=str2num(ws);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xx,yy,zz] = surf_nurbs_plot(surfnurbs, ni, nj, type, varargin)
%Disegna una superficie 3D nurbs
%surfnurbs --> struttura di una superficie spline:
%      surfnurbs.deguv --> grado della superficie in u e in v
%      surfnurbs.cp --> griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfnurbs.ku  --> vettore dei knot in u
%      surfnurbs.kv  --> vettore dei knot in v
%      surfnurbs.w --> griglia dei pesi (ncpu)x(ncpv)
%ni,nj --> numero di punti da plottare (nixnj) per ogni tratto 
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong'
%xx,yy,zz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%griglia di valutazione
%Algoritmo1: usa B-spline
%Algoritmo2: usa de Boor
%TODO
%disegna superficie in modalita' wire-frame
%mesh(xx,yy,zz);
% %disegna superficie in modalita' shading
% surface=surf(xx,yy,zz)
% shading interp;
% view(45,30)
% lightangle(45,30);
% lightangle(225,30);
% set(gcf,'Renderer','zbuffer');
% lighting phong;
% set(surface,'SpecularColorReflectance',0,'SpecularExponent',50);
% %se richiesto disegna i punti di controllo
% flag=0;
% if (flag)
%   plot3(x,y,z,col);
%   plot3(x',y',z',col);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surfnurbs=surf_nurbs_revolved(nurbs)
%Genera una superficie 3D nurbs per rotazione di una curva 3D nurbs
%nel piano xz intorno all'asse z
%nurbs --> struttura formata da 4 campi:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%surfnurbs <-- struttura di una superficie spline:
%      surfnurbs.deguv <-- grado della superficie in u e in v
%      surfnurbs.cp <-- griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfnurbs.ku  <-- vettore dei knot in u
%      surfnurbs.kv <-- vettore dei knot in v
%      surfnurbs.w <-- griglia dei pesi (ncpu)x(ncpv)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surfnurbs=surf_nurbs_ruled(nurbsA,nurbsB)
%Genera una superficie 3D nurbs rigata di due curve 3D nurbs
%nurbsA --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%nurbsB --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%surfnurbs <-- struttura di una superficie nurbs:
%      surfnurbs.deguv <-- grado della superficie in u e in v
%      surfnurbs.cp <-- griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfnurbs.ku  <-- vettore dei knot in u
%      surfnurbs.kv <-- vettore dei knot in v
%      surfnurbs.w <-- griglia dei pesi (ncpu)x(ncpv)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surf_nurbs_save(filename, surfnurbs)
%Scrive una superficie 3D nurbs su file
%filename --> nome del file di estensione .db
%surfnurbs --> struttura di una superficie spline:
%      surfnurbs.deguv --> grado della superficie in u e in v
%      surfnurbs.cp --> griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfnurbs.ku  --> vettore dei knot in u
%      surfnurbs.kv  --> vettore dei knot in v
%      surfnurbs.w --> griglia dei pesi (ncpu)x(ncpv)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i        %i\n',surfnurbs.deguv(1),surfnurbs.deguv(2));
%i        %i\n',m,n);
%i        %i\n',ntu,ntv);
%e %e %e %e\n',surfnurbs.cp(i,j,1),surfnurbs.cp(i,j,2),surfnurbs.cp(i,j,3),W(i,j));
%e\n',surfnurbs.ku(i));
%e\n',surfnurbs.kv(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surfnurbs = surf_nurbs_swung(nurbsA,nurbsB,scal)
%Genera una superficie 3D nurbs di swinging di due curve 3D nurbs
%nurbsA --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%nurbsB --> struttura di una curva nurbs:
%          nurbs.deg --> grado della curva
%          nurbs.cp  --> lista dei punti di controllo (ncp x3)
%          nurbs.knot  --> vettore dei nodi (ncp+nurbs.deg+1)
%          nurbs.w --> lista dei pesi (ncp)
%scal --> scalare
%surfnurbs <-- struttura di una superficie nurbs:
%      surfnurbs.deguv <-- grado della superficie in u e in v
%      surfnurbs.cp <-- griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfnurbs.ku  <-- vettore dei knot in u
%      surfnurbs.kv <-- vettore dei knot in v
%      surfnurbs.w <-- griglia dei pesi (ncpu)x(ncpv)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [pu,pv] = surf_param(param,npu,npv,x,y,z)
%Calcola la parametrizzazionedi una griglia di punti 3D  
%param  --> scelta della parametrizzazione
%           0=uniforme, 1=centripeta, 2=corda
%npu    --> numero di punti nella direzione u
%npv    --> numero di punti nella direzione v
%X      --> vettore delle ascisse
%Y      --> vettore delle ordinate
%Z      --> vettore delle quote
%pu     <-- parametrizzazione della griglia nella direzione u
%pv     <-- parametrizzazione della griglia nella direzione v
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=surf_plot(surfname,a,b,nu,c,d,nv,type,varargin)
%Disegna una superficie
%surfname --> nome del file con l'espressione parametrica 
%             della superficie
%a,b --> intervallo di definizione in u
%nu  --> numero di punti di valutazione in u
%c,d --> intervallo di definizione in v
%nv  --> numero di punti di valutazione in v
%x,y,z <-- coordinate punti plottati
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong' 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surfspline = surf_spline_interp(Q,param,intu,intv)
%Calcola la superficie spline cubica di interpolazione 
%di una griglia di punti 3D 
%Q           --> matrice (n punti in direzione u)x(m punti in direzione v)x3
%param       --> scelta della parametrizzazione
%                      0=uniforme, 1=centripeta, 2=corda
%intu        --> scelta dell'interpolazione in direzione u
%                      1=derivate agli estremi, 2=not-a-knot, 
%                      3=naturale, 4=periodica
%intv        --> scelta dell'interpolazione in direzione v
%                      1=derivate agli estremi, 2=not-a-knot, 
%                      3=naturale, 4=periodica
%surfspline  <-- struttura della superficie spline 
%       surfspline.deguv  <-- grado della spline in u e v (1x2)
%       surfspline.knotu  <-- partizione nodale estesa nella direzione u
%       surfspline.knotv  <-- partizione nodale estesa nella direzione v
%       surfspline.cp     <-- matrice 3D dei control point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Gradi superficie (bicubica)
%Calcola parametrizzazione
%Calcola partizioni nodali superficie
%Interpolazione punti della griglia con curve nella direzione v
%GC290618 quando ciclo per i=1:npu si deve interpolare in v
%GC290618 dopo la prima batteria di interpolazioni, a seconda del metodo
%usato i punti da interpolare nella seconda passata possono essere cambiati
%Interpolazione punti griglia dei CP con curve nella direzione u
%GC290618 quando ciclo per i=1:npv si deve interpolare in u

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xx,yy,zz] = surf_spline_kurHK_plot(surfspline, ni, nj, cflag)
%Disegna una superficie 3D spline
%surfspline --> struttura di una superficie spline:
%      surfspline.deguv --> grado della superficie in u e in v
%      surfspline.cp --> griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfspline.ku  --> vettore dei knot in u
%      surfspline.kv  --> vettore dei knot in v
%ni,nv --> numero di punti da plottare (nixnj) per ogni tratto
%cflag --> 1.curvatura media
%          2.curvatura Gaussiana
%xx,yy,zz <-- coordinate dei punti plottati
%cc <-- valore curvatura nei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%griglia di valutazione
%Algoritmo1: usa B-spline
%Coefficienti della prima forma fondamentale
%Coefficienti della seconda forma fondamentale
%curvatura Media
%curvatura Gaussiana
%disegna superficie e curvatura

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surfspline = surf_spline_load(filename)
%Legge una superficie 3D spline da file
%filename --> nome del file di estensione .db
%surfspline <-- struttura di una superficie spline:
%      surfspline.deguv <-- grado della superficie in u e in v
%      surfspline.cp <-- griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfspline.ku  <-- vettore dei knot in u
%      surfspline.kv  <-- vettore dei knot in v
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s',1);
%s',1);
%5d',1);    %grado in u
%5d',1);    %grado in v
%s',1);
%5d',1);   %num. control point in u
%5d',1);
%s',1);
%5d',1);    %num. nodi in u
%5d',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);
%s',1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [xx,yy,zz] = surf_spline_plot(surfspline, ni, nj, type, varargin)
%Disegna una superficie 3D spline
%surfspline --> struttura di una superficie spline:
%      surfspline.deguv --> grado della superficie in u e in v
%      surfspline.cp --> griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfspline.ku  --> vettore dei knot in u
%      surfspline.kv  --> vettore dei knot in v
%ni,nv --> numero di punti da plottare (nixnj) per ogni tratto 
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong' 
%xx,yy,zz <-- coordinate dei punti plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%griglia di valutazione
%Algoritmo1: usa B-spline
%Algoritmo2: usa de Boor
%TODO
%disegna superficie in modalita' wire-frame
%mesh(xx,yy,zz);
% %disegna superficie in modalita' shading
% surface=surf(xx,yy,zz)
% shading interp;
% view(45,30)
% lightangle(45,30);
% lightangle(225,30);
% set(gcf,'Renderer','zbuffer');
% lighting phong;
% set(surface,'SpecularColorReflectance',0,'SpecularExponent',50);
% %se richiesto disegna i punti di controllo
% flag=0;
% if (flag)
%   plot3(x,y,z,col);
%   plot3(x',y',z',col);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function surf_spline_save(filename, surfspline)
%Scrive una superficie 3D spline su file
%filename --> nome del file di estensione .db
%surfspline --> struttura di una superficie spline:
%      surfspline.deguv --> grado della superficie in u e in v
%      surfspline.cp --> griglia dei punti di controllo (ncpu)x(ncpv)x3
%      surfspline.ku  --> vettore dei knot in u
%      surfspline.kv  --> vettore dei knot in v
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%s\n',filename);
%i        %i\n',surfspline.deguv(1),surfspline.deguv(2));
%i        %i\n',m,n);
%i        %i\n',ntu,ntv);
%e %e %e\n',surfspline.cp(i,j,1),surfspline.cp(i,j,2),surfspline.cp(i,j,3));
%e\n',surfspline.ku(i));
%e\n',surfspline.kv(i));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=surf_trans_plot(surfname,a,b,nu,c,d,nv,M,type,varargin)
%Disegna una superficie dopo aver applicato la trasformazione M
%surfname --> nome del file con l'espressione parametrica 
%             della superficie
%a,b --> intervallo di definizione in u
%nu  --> numero di punti di valutazione in u
%c,d --> intervallo di definizione in v
%nv  --> numero di punti di valutazione in v
%M --> matrice di trasformazione 4x4
%type--> tipo di disegno
%      1: mesh hidden-line 
%      2: mesh colorata 
%      3: mesh personalizzabile
%varargin --> se type = 3, specificare manualmente le proprieta' del disegno
%             FaceColor: 'none', 'flat', 'interp', colorname 
%             EdgeColor: 'none', 'flat', 'interp', colorname 
%             FaceLightning: 'flat', 'gouraud', 'none', 'phong' 
%x,y,z <-- coordinate punti trasformati e plottati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=s_cone(u,v)
%Definizione parametrica sella superficie laterare di
%un tronco di cono
%u,v   --> valori parametrici in [0,2]x[0,2*pi]
%x,y,z --> punto 3D della superficie
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=s_cone_param(A,B,rA,rB,u,v)
%Definizione parametrica della superficie di un tronco di cono
%di asse definito dai punti 3D A e B con raggi di base rA ed rB
%A,B   --> punti 3D che definiscono l'asse del tronco di cono
%rA,rB --> raggi delle basi
%u,v   --> valori parametrici in [0,2*pi]x[0,1]
%x,y,z --> punto 3D della superficie
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%cerchio di centro O, raggio r giacente sul piano
%con normale n per t in [0,2*pi]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=s_cylinder(u,v)
%Definizione parametrica sella superficie laterare di
%un cilindro
%u,v   --> valori parametrici in [0,2]x[0,2*pi]
%x,y,z --> punto 3D della superficie
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=s_cylinder_param(A,B,r,u,v)
%Definizione parametrica della superficie cilindrica
%di asse definito dai punti 3D A e B con raggio di base r
%A,B   --> punti 3D che definiscono l'asse del tronco di cono
%r     --> raggio di base
%u,v   --> valori parametrici in [0,2*pi]x[0,1]
%x,y,z --> punto 3D della superficie
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%cerchio di centro O, raggio r giacente sul piano
%con normale n per t in [0,2*pi]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [x,y,z]=s_sphere_param(O,r,u,v)
%Definizione parametrica della superficie sferica di centro O
%e raggio r
%u,v   --> valori parametrici in [0,2*pi]x[0,2*pi]
%x,y,z --> punto 3D della superficie
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vect2_plot(p,v,varargin)
%Disegna il vettore 2D definito dal punto 2D p e dal vettore v
%p  --> punto 2D
%v  --> vettore 2D
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth, 
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize, 
%             ArrowFaceSize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%Default per i parametri opzionali
%Sovrascrivo in optargs gli opzionali specificati in varargin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vect2_trans_plot(p,v,M,varargin)
%Disegna il vettore 2D definito dal punto 2D p e dal vettore 2D v
%dopo averlo trasformato con la matrice M
%p  --> punto 2D
%v  --> vettore 2D
%M  --> matrice 3x3 di trasformazione
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize,
%             ArrowFaceSize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%Default per i parametri opzionali
%Sovrascrivo in optargs gli opzionali specificati in varargin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vect3_plot(p,v,varargin)
%Disegna il vettore 3D definito dal punto 3D p e dal vettore 3D v
%p  --> punto 3D
%v  --> vettore 3D
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize,
%             ArrowFaceSize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%Default per i parametri opzionali
%Sovrascrivo in optargs gli opzionali specificati in varargin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function vect3_trans_plot(p,v,M,varargin)
%Disegna il vettore 3D definito dal punto 3D p e dal vettore v 3D
%dopo averlo trasformato con la matrice M
%p  --> punto 3D
%v  --> vettore 3D
%M  --> matrice 4x4 di trasformazione
%varargin --> argomenti opzionali di disegno da assegnare nel seguente
%             ordine: LineSpecification, LineWidth,
%             MarkerEdgeColor, MarkerFaceColor, MarkerSize,
%             ArrowFaceSize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check sul numero di opzionali inseriti
%Default per i parametri opzionali
%Sovrascrivo in optargs gli opzionali specificati in varargin

%APPLICATION
%initialize bezierCurves to empty BezierCurve array
%call function to draw a new bezier curve
%renizialize it to empty BezierCurves array

%BEZIERCURVE Class for handling bezier curves
%initialize plots array to empty vectors
%initialize control points to empty vector
%initialize control number
%initialize control pieces to empty vector;
%default curve is not closed
%initialize curve's variables to empty vectors
%s\n',filename);
%i\n',nc);
%i\n',g);
%i\n',vind(i)-vind(i-1));
%e %e\n',this.controlPoints(1,i),this.controlPoints(2,i));
%e\n',i);
%create a vector of 100 equally spaced points between 0 and 1 
%calculate the vector of x positions of the curve
%calculate the vector of y positions of the curve
%find the neares point and get it derivative
%create array of distance between the searched point and the
%evaluated point
%calculate norm of each pair
%fid the minimum value (least squares distance)
%get coordinate value
%return also this for draw precisely the tangent/normal
%get derivative value
%get derivative at the given points
%linear space between [-1,1] instead of [0,1] for drawing also a backward line
%normalize vector
%create line
%get derivative value at the given points
%determine ortogonal vector
%normalize vector
%create line
%function to get the norm of the derivatives
%mapping index from [0,1] to [1,1000]
%get left extreme function value
%get right extreme function value
%get not composite integral initial value

%DECASTWITHDERIVATIVE evaluate the value of the polyonomial and derivative
% evaluate the value of the polyonomial and derivative given the
% polyonimal's coefficents and evaluation points.
%for each point
%the initial row is made by the coefficients
%get current evaluation point
%calculates its complementary to one
%every new row is shorter of 1 because is a triangular construction 
%the formula is https://wikimedia.org/api/rest_v1/media/math/render/svg/5634c700f37bf9bd30ab82043bf18a102bbf93a2  
%the value of the polynomial at the i point is the first element(the top
%of the triangular)
%the derivative at the point i 
%calculate last point derivative

%GRAPHICALINTERFACE Manage the interface of the application
%all the buttons
%create a figure with defined title and hide showing figure number in title
%hide the menu
%get screen dimension
%set figure position and dimension according to screen dimension
%use the same length for the data units along each axis
%set axis limits
%get the current axis handler
%set the unit of measurement to pixel
%ginput() and plot() still use dimension based on cartesian coordinate
%set axis left-margin, bottom-margin, width and height
%define clear button but set to invisible for now
%define button for adding a curve, but hide it for now
%define button for showing tangent, but hide it for now
%define button for showing normal, but hide it for now
%define button for calculate length of the curve, but hide it for now
%define add composite curve botton but set to invisible for now
%save the curve
%define text for giving istruction to the user
%set hold state to on so adding new points doesn't delete old points
%set istructions for the user
%set clear button and add button to invisible during drawing
%plot a blue cicle at the given coordinates
%after a curve is drawn, set to visible the clear button
%display all the button for features related to drawed curves
%and also the add curve button and add piece button
%if the last curve is closed, addPieceButton is not visible
%modify instructions
%plot bezier curve with control polygonal given a set of points
%get bezier curve by given index
%initilize variables that will trace the pieces 
%delete old plots if present   
%reinitialize curve's plots to empty vectors
%reinitialize curve's to empty vectors
%find the point where ends a curve
% draw control polygonal
%move the control polygonal to minimum z-index for better
%click detection on control points
%calculate bezier curve
%draw red solid line bézier curve
%move the bezier curve plot to minimum z-index for better
%click detection on control points
%while will stop when Final is equal to the length of
%controlPieces array
%clear everything except this
%delete all the control point graphic object
%empties array
%delete one by one all the plots
%enter mode for drawing new curve
%find object given its tag
%delete graphic object
%iterate through the point and set Visible to off
%iterate through the curves and hide polygonal
%change button string
%set 'show' callback on button click
%iterate through the point and set Visible to on
%iterate through the curves and show polygonal
%change button string
%set 'hide' callback on button click
%update control point "plot"
%plot the given point
%set to minimum z-index so the user can click in the same point
%for the normal/tangent.
%called on curve modify 
%delete all the tangents and normals if there are any
%empties array
%change instruction for the use
%tangent mode
%normal mode
%length mode
%drawing mode
%drag and drop mode
%nothing mode
%saving mode


%TRAPEZOID numerical integration with trapezoid method
% a -> left interval margin
% b -> right interval margin

%TRAPEZOID_ADAPT adaptive composite integration with trapezoid method
% a -> left interval margin
% b -> right interval margin
% fa -> function value in left interval margin
% fb -> function value in right interval margin
% tolerance -> stop condition
% trapAB -> integral computed with step h
%integral computed with step h/2
%error estimation
%richardson extrapolation and exit
%recurvise call on subintervals

%USERINTERACTIONAGENT 
%clear the graph and ask the user a set of points for a new bezier curve
%get graphical interface
%get bezier curves
%add a curve to the list of curves
%initialize control point indexthisthis
%matlab doesn't support do-while loop so first we set a true contition
%while the user had clicked the left mouse button
%wait for user click
%if the left of central mouse button is pressed
%if the central mouse buton is pressed
%set the control point equal to the first control point for closing
%the curve
%set closed curve flag to 1
%increse the control point index
%add the point to the control point array
%the size is been already increased with latest command so only
%use end here
%if the curve is not closed (in a closed curve the latest
%control point will not be plotted)
%update application bezier curves
%draw the bezier curve
%get graphical interface
%get bezier curves
%initialize control point indexthisthis
%matlab doesn't support do-while loop so first we set a true contition
%while the user had clicked the left mouse button
%wait for user click
%if the left of central mouse button is pressed
%if the central mouse buton is pressed
%set the control point equal to the first control point for closing
%the curve
%set closed curve flag to 1
%increse the control point index
%add the point to the control point array
%the size is been already increased with latest command so only
%use end here
%if the curve is not closed (in a closed curve the latest
%control point will not be plotted)
%update application bezier curves
%draw the bezier curve
%called upon click on control point, activates drag and drop
%get current figure handler
%set a listener for mouse move event
%set a listener for mouse button relase event
%get graphical interface
%called on drag of control point
%get the current position of the mouse
%get graphical interface
%move the graphical point on the axes
%change the point in the control point array
%get bezier curves
%if we are moving the first control point and is a closed curve
%get the index of the last control point
%move also the last control point
%get current axes handler
%get the pixel position and dimension of the axes
%axesPosition is an array of 4 element x,y,width and height
%calculate pixel offset related to axes position
%map pixel position to cartesian position
%get bezier curves
%update control point array
%get graphical interface
%update application bezier curves
%re-draw bezier curve
%called after clicked on a control point and relased the mouse button.
%get current figure handler
%remove listener for mouse move event
%remove listener for mouse button relase event
%get graphical interface
%get bezier curve
%mode=0 if user asked for tangent, 1 for normal , 2 for length,
%       6 for save curve
%get the position of the click
%get selected bezier curve
%tangent mode
%normal mode
%length mode
%save mode
%used to see basic information of curves in the Matlab's Command
%Window
%d control points with the following coordinates:\n',length(bezierCurves(i).controlPoints));
%d control points with the following coordinates:\n',length(bezierCurves(i).controlPoints));
%                 fprintf('Stylized form: ');
%                 while(i1 <= length(bezierCurves(i).controlPieces))
%                     if (bezierCurves(i).controlPieces(i1) == 0)
%                         fprintf('- ');
%                     else
%                         fprintf('1 ');
%                     end
%                     i1=i1+1;
%                 end
%                 fprintf('\n_____________________________________________________________\n');

