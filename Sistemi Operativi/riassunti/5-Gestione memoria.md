La gestione della memoria (RAM) è diversa da quella del processore centrale (CPU). La CPU può accedere solamente alla RAM che è abbastanza grande da consentire la multiprogrammazione e ha velocità comparabile a quella del processore.
### Garantire che ogni processo occupi uno spazio in memoria distinto
Bisogna determinare l'intervallo di indirizzi di memoria validi che il processo può accedere e limitarlo solo ad esso. Questa protezione è fornita da da due registri: 
- base: contiene il più piccolo indirizzo di memoria 
- limit: specifica la dimensione dell'intervallo.
![[registri_limit_base.svg]]
Un programma eseguito dall'utente che prova ad accedere alla memoria del sistema operativo di un altro utente attiva una trap al SO, restituendo un FatalError. I registri base e limit possono essere modificati solo dal SO tramite un istruzione speciale.
![[controlli_indirizzi_memoria.svg]]
### Portare la memoria da disco a RAM 
Nei sistemi moderni, un processo utente può risiedere in qualsiasi parte della memoria fisica, quindi non è necessario che l'indirizzo di inizio del processo utente sia 00000. Durante il processo di esecuzione, gli indirizzi vengono rappresentati in diverse fasi:
- Compilazione: Se si conosce già durante la compilazione dove il processo risiederà in memoria, allora è possibile generare un **codice assoluto**. Ad esempio, se si sa che un processo utente risiederà in una certa posizione, il codice del compilatore generato inizierà da lì e si estenderà da lì in su. Tuttavia, se in seguito la posizione di partenza cambia, sarà necessario ricompilare il codice.
- Linking/Caricamento: Se non si conosce durante la compilazione dove il processo risiederà in memoria, allora il compilatore deve generare un **codice rilocabile**. In questo caso, il legame finale viene posticipato al tempo di caricamento. Se la posizione di partenza cambia, sarà sufficiente ricaricare il codice utente per incorporare questo valore modificato.
- Esecuzione: Se il processo può essere spostato durante la sua esecuzione da un segmento di memoria a un altro, allora il legame deve essere posticipato fino al momento dell'esecuzione.
### Indirizzo logico e indirizzo fisico
Un indirizzo generato dalla CPU è l'indirizzo logico, mentre quello caricato nel memory address register (MAR) è l'indirizzo fisico.
1. **Indirizzo Simbolico**: Gli indirizzi simbolici sono utilizzati nel codice sorgente del programma e rappresentano simboli come nomi di variabili, funzioni o etichette. Questi indirizzi non sono direttamente associati a posizioni specifiche in memoria, ma sono piuttosto nomi convenzionali o simbolici utilizzati dal programmatore per riferirsi a parti specifiche del codice o dei dati. Gli indirizzi simbolici nel codice sorgente vengono tradotti in indirizzi logici durante la compilazione del programma.
2. **Indirizzo Logico (o Virtuale)**: Gli indirizzi logici sono quelli utilizzati dal programma durante l'esecuzione. Sono generati dal sistema operativo e rappresentano gli indirizzi a cui il programma accede, ma non corrispondono direttamente a posizioni fisiche nella memoria del computer. Gli indirizzi logici sono utilizzati per creare una mappatura astratta e conveniente dello spazio di memoria del programma. Durante l'esecuzione del programma, gli indirizzi logici possono essere mappati o tradotti in indirizzi fisici dal sistema operativo e dall'hardware (MMU).
3. **Indirizzo Fisico**: Gli indirizzi fisici rappresentano le posizioni reali della memoria del computer. Sono indirizzi diretti utilizzati dal processore e dalla memoria per accedere fisicamente ai dati e alle istruzioni. Gli indirizzi fisici sono associati direttamente alla posizione effettiva di celle di memoria nel hardware del computer. L'associazione tra indirizzi logici e indirizzi fisici può essere dinamica e può variare durante l'esecuzione del programma, soprattutto nei sistemi di memoria virtuale dove la gestione della memoria viene ottimizzata per fornire uno spazio degli indirizzi logici più grande di quello fisicamente disponibile.
### Memory Management Unit (MMU)
La MMU è un dispositivo hardware che converte gli indirizzi virtuali in indirizzi fisici. Il valore del registro di rilocazione è generato da un processo dell'utente quando viene inviato in memoria. Il programma dell'utente usa indirizzi logici, non vede mai gli indirizzi fisici.
![[memory_management_unit.svg]]
### Librerie collegate dinamicamente
Una libreria dinamicamente collegata è una libreria di sistema che viene collegata a un programma utente solo quando il programma viene eseguito, anziché essere incorporata nell'immagine binaria del programma stesso durante la fase di compilazione.
Con il collegamento dinamico, quando un programma ha bisogno di utilizzare una funzione da una libreria di sistema, non carica immediatamente tutta la libreria in memoria. Invece, quando viene eseguito il programma, viene inserito un piccolo pezzo di codice chiamato "stub" nell'immagine del programma. Lo stub contiene istruzioni su come trovare o caricare la funzione di libreria necessaria quando viene chiamata.

Quando il programma raggiunge quel punto e necessita della funzione della libreria, lo stub controlla se quella funzione è già caricata in memoria. Se non lo è, il programma la carica. In entrambi i casi, lo stub si sostituisce con l'indirizzo della funzione e l'esegue. In questo modo, quando quel segmento di codice viene raggiunto di nuovo, la funzione della libreria viene eseguita direttamente, senza dover ricorrere nuovamente al collegamento dinamico. Questo processo permette una gestione efficiente delle risorse di sistema, poiché le funzioni della libreria vengono caricate solo quando necessario, riducendo la quantità di memoria e spazio su disco utilizzati.
### Swapping
Un processo deve trovarsi in memoria per essere eseguito, ma può essere temporaneamente spostato dalla memoria a uno spazio di archiviazione secondario (detto backing store) e successivamente riportato in memoria per continuare l'esecuzione. Lo swapping rende possibile superare lo spazio fisico totale della memoria disponibile nel sistema, permettendo così un maggior grado di multiprogrammazione.

Quando il sistema ha esaurito la memoria fisica dedicata ai processi (RAM), può utilizzare lo swapping per liberare memoria spostando momentaneamente alcuni processi su uno spazio di archiviazione secondario, come un disco rigido. In questo modo, la memoria fisica viene liberata per l'esecuzione di nuovi processi. Quando un processo spostato è richiamato, viene riportato in memoria principale dallo spazio di archiviazione secondario.